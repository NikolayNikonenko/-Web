@page "/reliability-monitor"
@using перенос_бд_на_Web.Models
@using перенос_бд_на_Web.Data
@using перенос_бд_на_Web.Services
@using Microsoft.EntityFrameworkCore
@* @inject ApplicationContext DbContext *@
@inject SliceService sliceService
@inject IJSRuntime JS
@inject ReliabilityAnalyzer ReliabilityAnalyzer
@inject PowerImbalanceService PowerImbalanceService
@inject IDbContextFactory<ApplicationContext> ContextFactory
@inject ReportService ReportService
@inject ExistingReportService ExistingReportService

@implements IDisposable

@code {
    private readonly IDbContextFactory<ApplicationContext> _contextFactory;

    private bool isProcessing = false;
    private int successfulCount = 0;
    private int totalCount = 0;
    private int currentProgress = 0;
    // private ElementReference chartElement;
    private ElementReference chartFirstSetRef;
    private ElementReference chartSecondSetRef;
    private CancellationTokenSource cancellationTokenSource;
    private DateTime? startDateTime;
    private DateTime? endDateTime;
    private string errorMessage;
    private bool isChartReady = false;

    private double maxActivePowerImbalance;
    private double maxReactivePowerImbalance;
    private double averageTotalActivePowerImbalance;
    private double averageTotalReactivePowerImbalance;
    private double averageDeviation;
    private double standardDeviation;

    private string firstSelectedSet;
    private string secondSelectedSet;
    private List<string> uniqueExperimentLabels;

    private double firstMaxActivePowerImbalance;
    private double firstMaxReactivePowerImbalance;
    private double firstAverageTotalActivePowerImbalance;
    private double firstAverageTotalReactivePowerImbalance;
    private double firstAverageDeviation;
    private double firstStandardDeviation;

    private double secondMaxActivePowerImbalance;
    private double secondMaxReactivePowerImbalance;
    private double secondAverageTotalActivePowerImbalance;
    private double secondAverageTotalReactivePowerImbalance;
    private double secondAverageDeviation;
    private double secondStandardDeviation;

    private bool isDataAddedToReport = false;

    private (int successfulCount, int totalCount) firstSetResults;
    private (int successfulCount, int totalCount) secondSetResults;

    private int firstSetProgress = 0;
    private int secondSetProgress = 0;

    private string _rootSaveReportDirectory;


    private  ApplicationContext _context;
    private Guid reportId; // Хранение ID отчёта
    public string savePath;

    private bool ShowReportForm = false;
    private List<ReportWithIndicatorsViewModel> Reports = new();

    private bool IsFormVisible = false;


    private ReportWithIndicatorsViewModel? SelectedReportWithIndicators;
    private Dictionary<string, List<ReliabilityAndValidityIndicators>>? GroupedIndicators;

    private bool isLoadedReport;


    protected override async Task OnInitializedAsync()
    {
        // Загрузка отчетов при инициализации компонента
        Reports = await ExistingReportService.GetAllReportsAsync();

        _context = ContextFactory.CreateDbContext();
        //await using var context = ContextFactory.CreateDbContext();
        // Загружаем уникальные значения из колонки experiment_label
        uniqueExperimentLabels = await _context.slices
            .Select(s => s.experiment_label)
            .Distinct()
            .ToListAsync();

        firstSelectedSet = uniqueExperimentLabels.FirstOrDefault();
        secondSelectedSet = uniqueExperimentLabels.Skip(1).FirstOrDefault();

        _rootSaveReportDirectory = GetParameterValue("ReportDataPath");

        savePath = Path.Combine(_rootSaveReportDirectory,
                                $"Отчет_{DateTime.Now:yyyyMMdd_HHmm}.docx");

    }


    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            firstRender = false;
        }
        else if (isChartReady && !isProcessing)
        {
            await DrawChart();
            isChartReady = false; // Сбрасываем флаг
        }
    }


    private string GetParameterValue(string parameterName)
    {
        var parameter = _context.configuration_parameters
        .FirstOrDefault(p => p.parameter_name == parameterName);

        if (parameter == null)
        {
            throw new Exception($"Параметр с именем {parameterName} не найден в таблице configuration_parameters");
        }
        return parameter.parameter_value;
    }

    private async Task ProcessReliabilityData(bool useNewLogic)
    {
        if (startDateTime == null || endDateTime == null)
        {
            errorMessage = "Необходимо указать начальную и конечную дату и время.";
            return;
        }

        if (startDateTime >= endDateTime)
        {
            errorMessage = "Дата начала должна быть меньше даты окончания.";
            return;
        }

        if (string.IsNullOrEmpty(firstSelectedSet) || string.IsNullOrEmpty(secondSelectedSet))
        {
            errorMessage = "Необходимо выбрать оба набора для сравнения.";
            return;
        }
        if (firstSelectedSet == secondSelectedSet)
        {
            errorMessage = "Сравниваемые наборы не должны быть одинаковыми.";
            return;
        }

        isProcessing = true;
        cancellationTokenSource = new CancellationTokenSource();
        errorMessage = null;

        try
        {
            // Параллельная загрузка путей для обоих наборов
            var filePathsTasks = new[]
            {
                sliceService.GetFilePathsInRangeAsync(startDateTime.Value, endDateTime.Value, firstSelectedSet),
                sliceService.GetFilePathsInRangeAsync(startDateTime.Value, endDateTime.Value, secondSelectedSet)
            };


            var filePathsResults = await Task.WhenAll(filePathsTasks);
            var filePathsFirstSet = filePathsResults[0];
            var filePathsSecondSet = filePathsResults[1];


            if (filePathsFirstSet.Count == 0 || filePathsSecondSet.Count == 0)
            {
                errorMessage = "Не найдено файлов в указанном интервале времени.";
                return;
            }

            // Параллельный анализ данных обоих наборов
            var analyzeTasks = new[]
            {
                Task.Run(() => AnalyzeSetDataAsync(filePathsFirstSet,1, useNewLogic)),
                Task.Run(() => AnalyzeSetDataAsync(filePathsSecondSet,2, useNewLogic))
            };

            var analyzeResults = await Task.WhenAll(analyzeTasks);
            firstSetResults = analyzeResults[0];
            secondSetResults = analyzeResults[1];

            // Параллельная загрузка метрик обоих наборов
            var loadMetricsTasks = new[]
            {
                Task.Run(() => LoadMetricsAsync(filePathsFirstSet, true)),
                Task.Run(() => LoadMetricsAsync(filePathsSecondSet, false))
            };

            await Task.WhenAll(loadMetricsTasks);

            isChartReady = true; // Флаг для отрисовки диаграмм
        }
        catch (Exception ex)
        {
            errorMessage = $"Ошибка при анализе данных: {ex.Message}";
        }
        finally
        {
            isProcessing = false;
            cancellationTokenSource.Dispose();
            cancellationTokenSource = null;
        }

        StateHasChanged(); // Обновление интерфейса
    }


    private async Task LoadMetricsAsync(IEnumerable<string> slicePaths, bool isFirstSet)
    {
        // Обращение к PowerImbalanceService для расчета метрик
        await using var context = ContextFactory.CreateDbContext();

        var metrics = await PowerImbalanceService.CalculateMetricsAsync(slicePaths);

        if (isFirstSet)
        {
            firstMaxActivePowerImbalance = metrics.MaxActivePowerImbalance;
            firstMaxReactivePowerImbalance = metrics.MaxReactivePowerImbalance;
            firstAverageTotalActivePowerImbalance = metrics.AverageTotalActivePowerImbalance;
            firstAverageTotalReactivePowerImbalance = metrics.AverageTotalReactivePowerImbalance;

            firstAverageDeviation = await CalculateAverageDeviationAsync(slicePaths);
            firstStandardDeviation = await CalculateStandardDeviationAsync(slicePaths);
        }
        else
        {
            secondMaxActivePowerImbalance = metrics.MaxActivePowerImbalance;
            secondMaxReactivePowerImbalance = metrics.MaxReactivePowerImbalance;
            secondAverageTotalActivePowerImbalance = metrics.AverageTotalActivePowerImbalance;
            secondAverageTotalReactivePowerImbalance = metrics.AverageTotalReactivePowerImbalance;

            secondAverageDeviation = await CalculateAverageDeviationAsync(slicePaths);
            secondStandardDeviation = await CalculateStandardDeviationAsync(slicePaths);
        }
    }

    private async Task<(int successfulCount, int totalCount)> AnalyzeSetDataAsync(List<string> filePaths, int setNumber, bool useNewLogic)
    {
        if (useNewLogic)
        {
            // Логика с использованием нового метода
            var result = await ReliabilityAnalyzer.AnalyzeNewReliabilityData(
                _context,
                startDateTime.Value,
                endDateTime.Value,
                filePaths,
                progress => UpdateProgress(setNumber, progress),
                cancellationTokenSource.Token);

            return (result.successfulCount, result.totalCount);
        }
        else
        {
            // Старая логика
            var result = await ReliabilityAnalyzer.AnalyzeReliabilityData(
                startDateTime.Value,
                endDateTime.Value,
                filePaths,
                progress => UpdateProgress(setNumber, progress),
                cancellationTokenSource.Token);

            return (result.successfulCount, result.totalCount);
        }
    }

    private async Task<double> CalculateAverageDeviationAsync(IEnumerable<string> slicePaths)
    {
        await using var context = ContextFactory.CreateDbContext();

        // Шаг 1: Фильтрация данных через связь TMValues и Slices
        var filteredData = context.telemetry_values
            .Join(context.slices,           // Присоединяем таблицу Slices
                  tm => tm.SliceID,           // Поле связи из TMValues
                  slice => slice.SliceID,          // Поле связи из Slices
                  (tm, slice) => new { tm, slice }) // Результат - объединённые записи
            .Where(joined => slicePaths.Contains(joined.slice.SlicePath)) // Фильтрация по путям
            .Select(joined => joined.tm);     // Возвращаем только записи TMValues

        // Шаг 2: Группировка по уникальным сочетаниям IndexTM и Id1
        var averageDeviations = await filteredData
            .GroupBy(v => new { v.IndexTM, v.Id1 }) // Группировка по IndexTM и Id1
            .Select(group => group.Average(v => v.IzmerValue - v.OcenValue)) // Среднее отклонение для каждой группы
            .ToListAsync();

        // Шаг 3: Рассчитываем общее среднее: сумма всех средних значений / количество уникальных групп
        double totalSum = averageDeviations.Sum(); // Суммируем все средние значения
        int groupCount = averageDeviations.Count; // Количество уникальных групп

        // Шаг 4: Возвращаем итоговое значение
        return groupCount > 0 ? totalSum / groupCount : 0.0; // Проверка деления на 0
    }

    private async Task<double> CalculateStandardDeviationAsync(IEnumerable<string> slicePaths)
    {
        await using var context = ContextFactory.CreateDbContext();
        var query = context.telemetry_values
            .Join(context.slices,
                  tm => tm.SliceID,
                  slice => slice.SliceID,
                  (tm, slice) => new { tm.IzmerValue, slice.SlicePath })
            .Where(joined => slicePaths.Contains(joined.SlicePath))
            .Select(joined => joined.IzmerValue);

        // Среднее значение
        var mean = await query.AverageAsync();

        // Сумма квадратов отклонений
        var sumOfSquaresOfDifferences = await query
            .Select(val => (val - mean) * (val - mean))
            .SumAsync();

        // Количество значений
        var count = await query.CountAsync();

        return count > 0 ? Math.Sqrt(sumOfSquaresOfDifferences / count) : 0.0;
    }

    private async Task DrawChart()
    {
        if (firstSetResults.totalCount > 0)
        {
            await JS.InvokeVoidAsync("drawDonutChart", chartFirstSetRef, firstSetResults.successfulCount, firstSetResults.totalCount);
        }

        if (secondSetResults.totalCount > 0)
        {
            await JS.InvokeVoidAsync("drawDonutChart", chartSecondSetRef, secondSetResults.successfulCount, secondSetResults.totalCount);
        }
    }

    private void UpdateProgress(int setNumber, int progress)
    {
        if (setNumber == 1)
            firstSetProgress = progress;
        else
            secondSetProgress = progress;

        // Рассчитываем общий прогресс как среднее арифметическое
        currentProgress = (firstSetProgress + secondSetProgress) / 2;
        InvokeAsync(StateHasChanged);
    }

    public void Dispose()
    {
        cancellationTokenSource?.Cancel();
        cancellationTokenSource?.Dispose();
    }

    private double GetSuccessRate(int successfulCount, int totalCount)
    {
        return totalCount > 0 ? Math.Round((double)successfulCount / totalCount * 100, 3) : 0;
    }

    private async Task AddToReport()
    {
        //await using var context = ContextFactory.CreateDbContext();
        //await using var transaction = await _context.Database.BeginTransactionAsync(); // Начало транзакции
        try
        {
            // Проверка наличия данных перед вызовом сервиса
            if (firstSetResults.totalCount > 0 && secondSetResults.totalCount > 0)
            {
                // Получаем список экспериментов, связанных с firstSelectedSet и secondSelectedSet
                var experiments = await _context.experiment
                    .Include(e => e.ValidatedTelemetries) // Загрузка связанных телеизмерений
                    .Where(e => e.experiment_label == firstSelectedSet || e.experiment_label == secondSelectedSet) // Фильтр по меткам
                    .OrderBy(e => e.id_experiment)
                    .ToListAsync();

                // Формируем данные об экспериментах для отчета
                var experimentData = new List<ExperimentViewModel>();
                foreach (var experiment in experiments)
                {
                    foreach (var valTm in experiment.ValidatedTelemetries)
                    {
                        experimentData.Add(new ExperimentViewModel
                            {
                                ExperimentNumber = experiment.experiment_label,
                                DateExperiment = experiment.date_experiment,
                                CalculationInterval = $"от {experiment.start_date_experiment_interval} до {experiment.end_date_experiment_interval}",
                                ApplyFGO = experiment.apply_fgo,
                                TelemetryNumber = valTm.index_tm,
                                RecommendedAction = valTm.recomended_action
                            });
                    }
                }

                await ReportService.AddToReport(
                firstSelectedSet, secondSelectedSet,
                firstMaxActivePowerImbalance, secondMaxActivePowerImbalance,
                firstMaxReactivePowerImbalance, secondMaxReactivePowerImbalance,
                firstAverageTotalActivePowerImbalance, secondAverageTotalActivePowerImbalance,
                firstAverageTotalReactivePowerImbalance, secondAverageTotalReactivePowerImbalance,
                firstAverageDeviation, secondAverageDeviation,
                firstStandardDeviation, secondStandardDeviation,
                GetSuccessRate(firstSetResults.successfulCount, firstSetResults.totalCount),
                GetSuccessRate(secondSetResults.successfulCount, secondSetResults.totalCount),
                startDateTime, endDateTime,
                experimentData
                );
            }
            // Устанавливаем флаг, что данные добавлены
            isDataAddedToReport = true;

            //savePath = Path.Combine("D:\\учеба\\магистратура\\3 курс\\диплом ит\\мое\\тест отчеты",
            //$"Отчет_{DateTime.Now:yyyyMMdd_HHmm}.docx");

            // Создаём запись отчёта только один раз
            if (reportId == Guid.Empty)
            {
                reportId = await SaveRepotToDatabase(_context);
                //await SaveIdReportToWxperiment(reportId);


            }
            await GetReportFormat(reportId, _context);

        }
        catch (Exception ex)
        {
            //await transaction.RollbackAsync(); // Откат транзакции в случае ошибки
            Console.WriteLine($"Ошибка при добавлении в отчёт: {ex.Message}");
            throw; // Проброс ошибки

        }
    }

    private async Task SaveIdReportToExperiment(Guid reportId, List<(string setName, int countNos, int totalNumberOfOS, double maxNebP, double maxNebQ, double avgNebP, double
            avgNebQ, double avgMo, double sko, double successRate)> setsData)
    {
        // Получаем список всех экспериментов из базы данных
        var experiments = await _context.experiment.ToListAsync();

        foreach (var set in setsData)
        {
            // Находим эксперименты, у которых experiment_label совпадает с setName
            var matchingExperiments = experiments.Where(e => e.experiment_label == set.setName).ToList();

            foreach (var experiment in matchingExperiments)
            {
                experiment.id_report = reportId;
            }
        }
        // Сохраняем изменения в базе данных
        await _context.SaveChangesAsync();

    }


    private async Task GetReportFormat(Guid reportId, ApplicationContext _context)
    {
        var setsData = new List<(string setName, int countNos, int totalNumberOfOS, double maxNebP, double maxNebQ, double avgNebP, double avgNebQ, double avgMo, double sko, double successRate)>
        {
            (
                firstSelectedSet,
                firstSetResults.successfulCount,
                firstSetResults.totalCount,
                firstMaxActivePowerImbalance,
                firstMaxReactivePowerImbalance,
                firstAverageTotalActivePowerImbalance,
                firstAverageTotalReactivePowerImbalance,
                firstAverageDeviation,
                firstStandardDeviation,
                GetSuccessRate(firstSetResults.successfulCount, firstSetResults.totalCount)
            ),
            (
                secondSelectedSet,
                secondSetResults.successfulCount,
                secondSetResults.totalCount,
                secondMaxActivePowerImbalance,
                secondMaxReactivePowerImbalance,
                secondAverageTotalActivePowerImbalance,
                secondAverageTotalReactivePowerImbalance,
                secondAverageDeviation,
                secondStandardDeviation,
                GetSuccessRate(secondSetResults.successfulCount, secondSetResults.totalCount)
            )
        };

        await SaveReliabilityAndValidityIndicators(reportId, setsData, _context);
        await SaveIdReportToExperiment(reportId, setsData);
    }
    private async Task<Guid> SaveRepotToDatabase(ApplicationContext _context)
    {
        // Проверяем, существует ли уже отчёт с указанным путём
        var existingReport = await _context.report
            .FirstOrDefaultAsync(r => r.report_path == savePath);

        if (existingReport != null)
        {
            // Возвращаем ID существующего отчёта
            return existingReport.id_report;
        }

        //await using var context = ContextFactory.CreateDbContext();
        var newReport = new Report
        {
            id_report = Guid.NewGuid(),
            report_date = DateTime.Now,
            report_path = savePath
        };
        _context.report.Add(newReport);
        await _context.SaveChangesAsync();
        return newReport.id_report;
    }


    private async Task SaveReliabilityAndValidityIndicators(Guid reportId, 
        List<(string setName, int countNos, int totalNumberOfOS, double maxNebP, double maxNebQ, double avgNebP, double 
            avgNebQ, double avgMo, double sko, double successRate)> setsData, ApplicationContext _context)
    {
        foreach (var set in setsData)
        {
            // Распаковка данных набора
            //var (setName, countNos, totalNumberOfOS, maxNebP, maxNebQ, avgNebP, avgNebQ, avgMo, sko, successRate) = setData;

            var newReliabilityAndValidityIndicators = new ReliabilityAndValidityIndicators
            {
                id_indicator = Guid.NewGuid(),
                id_report = reportId,
                set_name = set.setName,
                count_nos = set.countNos,
                total_number_of_os = set.totalNumberOfOS,
                max_neb_p = set.maxNebP,
                max_neb_q = set.maxNebQ,
                avg_neb_p = set.avgNebP,
                avg_neb_q = set.avgNebQ,
                avg_mo = set.avgMo,
                sko = set.sko,
                success_rate = set.successRate
            };
            _context.reliability_and_validity_indicators.Add(newReliabilityAndValidityIndicators);
        }
        await _context.SaveChangesAsync();
    }

    private async Task SaveReport(string savePath)
    {

        try
        {
            // Вызов метода для сохранения отчета
            await ReportService.SaveReportAsync(savePath);
            Console.WriteLine("Отчет успешно сохранен!");
        }
        catch (Exception ex)
        {
            // Логирование ошибки
            Console.WriteLine($"Ошибка при сохранении отчета: {ex.Message}");
            //throw; // Проброс ошибки для отката транзакции
        }
    }

    private void ToggleReportForm()
    {
        IsFormVisible = true;
    }

    private async Task LoadReport(Guid reportId)
    {
        isProcessing = true; // Если используется флаг для блокировки UI
        isLoadedReport = true; // Отмечаем, что идет загрузка существующего отчета
        SelectedReportWithIndicators = await ExistingReportService.LoadReportAsync(reportId);

        // Определяем имена наборов для диаграмм
        var firstSetName = SelectedReportWithIndicators.Indicators.First().set_name;
        var secondSetName = SelectedReportWithIndicators.Indicators
            .FirstOrDefault(i => i.set_name != firstSetName)?.set_name;

        // Заполняем результаты для диаграмм с использованием кортежей
        firstSetResults = (
            successfulCount: SelectedReportWithIndicators.Indicators
                .FirstOrDefault(i => i.set_name == firstSetName)?.count_nos ?? 0,
            totalCount: SelectedReportWithIndicators.Indicators
                .FirstOrDefault(i => i.set_name == firstSetName)?.total_number_of_os ?? 1
        );

        secondSetResults = secondSetName != null ? (
            successfulCount: SelectedReportWithIndicators.Indicators
                .FirstOrDefault(i => i.set_name == secondSetName)?.count_nos ?? 0,
            totalCount: SelectedReportWithIndicators.Indicators
                .FirstOrDefault(i => i.set_name == secondSetName)?.total_number_of_os ?? 1
        ) : (0, 0);



        StateHasChanged(); // Обновление интерфейса
        await Task.Delay(100); // Ждем завершения рендера
        await DrawChart();
        isProcessing = false; // Снятие блокировки UI
    }

    private void CloseForm()
    {
        IsFormVisible = false;
    }


    private object GetIndicatorValue(ReliabilityAndValidityIndicators indicator, string indicatorName)
    {
        return indicatorName switch
        {
            "Максимальный небаланс по активной мощности" => Math.Round(indicator.max_neb_p, 3),
            "Максимальный небаланс по реактивной мощности" => Math.Round(indicator.max_neb_q, 3),
            "Усредненный суммарный небаланс по активной мощности" => Math.Round(indicator.avg_neb_p, 3),
            "Усредненный суммарный небаланс по реактивной мощности" => Math.Round(indicator.avg_neb_q, 3),
            "Среднее математическое ожидание" => Math.Round(indicator.avg_mo, 3),
            "Среднеквадратичное отклонение" => Math.Round(indicator.sko, 3),
            "Успешность" => Math.Round(indicator.success_rate, 3),
            _ => "N/A"
        };
    }


}

<PageTitle>Мониторинг надежности</PageTitle>

<h3>Мониторинг надежности</h3>

<!-- Сравнение наборов -->
<div class="d-flex align-items-center mb-3">
    <span class="me-2">Сравнивать набор:</span>
    <select id="firstSet" @bind="firstSelectedSet" class="form-select me-3" style="width: 200px;">
        @if (uniqueExperimentLabels != null && uniqueExperimentLabels.Any())
        {
            @foreach (var label in uniqueExperimentLabels)
            {
                <option value="@label">@label</option>
            }
        }
        else
        {
            <option value="" disabled>Загрузка...</option>
        }
    </select>
    <span class="me-2">с набором:</span>
    <select id="secondSet" @bind="secondSelectedSet" class="form-select" style="width: 200px;">
        @if (uniqueExperimentLabels != null && uniqueExperimentLabels.Any())
        {
            @foreach (var label in uniqueExperimentLabels)
            {
                <option value="@label">@label</option>
            }
        }
        else
        {
            <option value="" disabled>Загрузка...</option>
        }
    </select>
</div>

<!-- Диапазон времени -->
<div class="mb-3">
    <span>Выберите интересующий для анализа диапазон времени:</span>
</div>

<div class="d-flex align-items-center">
    <label for="startDateTime" class="me-2">Начало:</label>
    <input id="startDateTime" type="datetime-local" @bind="startDateTime" class="form-control me-3" style="width: 200px;" />

    <label for="endDateTime" class="me-2">Конец:</label>
    <input id="endDateTime" type="datetime-local" @bind="endDateTime" class="form-control" style="width: 200px;" />
</div>

<!-- Кнопка "Существующие отчеты" -->
<div class="mt-3 mb-3">
    <button class="btn btn-primary mt-2" @onclick="ToggleReportForm">Существующие отчеты</button>

</div>

@if (IsFormVisible)
{
    <div class="alert alert-info mt-3 position-relative" style="padding-bottom: 40px; height: auto; min-height: 300px; width: 50%; margin: 0 auto; max-width: 600px;">
        <h4>Проведенные отчеты</h4>
        <ol>
            @foreach (var report in Reports)
            {
                <li class="mb-2">
                    @report.ReportDate
                    <button class="btn btn-primary ms-2" @onclick="() => LoadReport(report.Id)">Загрузить отчет</button>
                </li>
            }
        </ol>
        <button class="btn btn-secondary position-absolute" style="bottom: 10px; right: 10px;" @onclick="CloseForm">Закрыть</button>
    </div>
}

<div class="mt-3">
    <button class="btn btn-primary" @onclick="() => ProcessReliabilityData(false)" disabled="@isProcessing">
        Показатели надежности без ЕОТМ
    </button>
</div>

<div class="mt-3">
    <button class="btn btn-primary" @onclick="() => ProcessReliabilityData(true)" disabled="@isProcessing">
        Показатели надежности с ЕОТМ
    </button>
</div>


@if (isProcessing)
{
    <div class="progress mt-3">
        <div class="progress-bar progress-bar-striped progress-bar-animated"
             role="progressbar"
             style="width: @currentProgress%"
             aria-valuenow="@currentProgress"
             aria-valuemin="0"
             aria-valuemax="100">
            @currentProgress%
        </div>
    </div>
}




@if (isLoadedReport && SelectedReportWithIndicators != null && SelectedReportWithIndicators.Indicators.Any())
{
    var firstSetName = SelectedReportWithIndicators.Indicators.First().set_name;
    var secondSetName = SelectedReportWithIndicators.Indicators
        .FirstOrDefault(i => i.set_name != firstSetName)?.set_name;

    // Подготовка результатов
    var firstSetResults = new
    {
        successfulCount = SelectedReportWithIndicators.Indicators.FirstOrDefault(i => i.set_name == firstSetName)?.count_nos ?? 0,
        totalCount = SelectedReportWithIndicators.Indicators.FirstOrDefault(i => i.set_name == firstSetName)?.total_number_of_os ?? 1
    };

    var secondSetResults = secondSetName != null ? new
    {
        successfulCount = SelectedReportWithIndicators.Indicators.FirstOrDefault(i => i.set_name == secondSetName)?.count_nos ?? 0,
        totalCount = SelectedReportWithIndicators.Indicators.FirstOrDefault(i => i.set_name == secondSetName)?.total_number_of_os ?? 1
    } : null;

    <div class="mt-4 text-center">
        <h5>Отчет от @SelectedReportWithIndicators.ReportDate</h5>

        <!-- Графики успешности ОС -->
        <div class="row justify-content-center">
            <!-- Первый график -->
            <div class="col-md-6">
                <h6>@firstSetName</h6>
                <div class="chart-container">
                    <canvas @ref="chartFirstSetRef"></canvas>
                </div>
                <p>Успешность ОС: @GetSuccessRate(firstSetResults.successfulCount, firstSetResults.totalCount)%</p>
            </div>

            <!-- Второй график -->
            @if (secondSetResults != null)
            {
                <div class="col-md-6">
                    <h6>@secondSetName</h6>
                    <div class="chart-container">
                        <canvas @ref="chartSecondSetRef"></canvas>
                    </div>
                    <p>Успешность ОС: @GetSuccessRate(secondSetResults.successfulCount, secondSetResults.totalCount)%</p>
                </div>
            }
        </div>

        <!-- Таблица показателей -->
        <table class="table mt-4">
            <thead>
                <tr>
                    <th>Показатель</th>
                    <th>Единицы измерения</th>
                    <th>@firstSetName</th>
                    @if (!string.IsNullOrEmpty(secondSetName))
                    {
                        <th>@secondSetName</th>
                    }
                </tr>
            </thead>
            <tbody>
                @foreach (var indicatorName in new[]
               {
            "Максимальный небаланс по активной мощности",
            "Максимальный небаланс по реактивной мощности",
            "Усредненный суммарный небаланс по активной мощности",
            "Усредненный суммарный небаланс по реактивной мощности",
            "Среднее математическое ожидание",
            "Среднеквадратичное отклонение",
            "Успешность"
            })
                {
                    <tr>
                        <td>@indicatorName</td>
                        <td>
                            @if (indicatorName.Contains("активной мощности"))
                            {
                                @("МВт")
                            }
                            else if (indicatorName.Contains("реактивной мощности"))
                            {
                                @("МВАр")
                            }
                            else if (indicatorName.Contains("математическое ожидание") || indicatorName.Contains("отклонение"))
                            {
                                @("(о.е.)")
                            }
                            else
                            {
                                @("%")
                            }
                        </td>
                        <td>
                            @{
                                var firstSetIndicator = SelectedReportWithIndicators.Indicators
                                .FirstOrDefault(i => i.set_name == firstSetName);

                                if (firstSetIndicator != null)
                                {
                                    @GetIndicatorValue(firstSetIndicator, indicatorName)
                                }
                            }
                        </td>
                        @if (!string.IsNullOrEmpty(secondSetName))
                        {
                            <td>
                                @{
                                    var secondSetIndicator = SelectedReportWithIndicators.Indicators
                                    .FirstOrDefault(i => i.set_name == secondSetName);

                                    if (secondSetIndicator != null)
                                    {
                                        @GetIndicatorValue(secondSetIndicator, indicatorName)
                                    }
                                }
                            </td>
                        }
                    </tr>
                }
            </tbody>
        </table>
    </div>
}


@if (firstSetResults.totalCount > 0 && secondSetResults.totalCount > 0 && !isLoadedReport)
{
    <div class="mt-4 text-center">
        <h5>Расчетный интервал: от @startDateTime до @endDateTime</h5>
        <div class="row justify-content-center">
            <!-- Первый график -->
            <div class="col-md-6">
                <h6>@firstSelectedSet</h6>
                <div class="chart-container">
                    <canvas @ref="chartFirstSetRef"></canvas>
                </div>
                <p>Успешность ОС: @GetSuccessRate(firstSetResults.successfulCount, firstSetResults.totalCount)%</p>
            </div>
            <!-- Второй график -->
            <div class="col-md-6">
                <h6>@secondSelectedSet</h6>
                <div class="chart-container">
                    <canvas @ref="chartSecondSetRef"></canvas>
                </div>
                <p>Успешность ОС: @GetSuccessRate(secondSetResults.successfulCount, secondSetResults.totalCount)%</p>
            </div>
        </div>

        <table class="table mt-4">
            <thead>
                <tr>
                    <th>Показатель</th>
                    <th>Единицы измерения</th>
                    <th>@firstSelectedSet</th>
                    <th>@secondSelectedSet</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Максимальный небаланс по активной мощности</td>
                    <td>МВт</td>
                    <td>@Math.Round(firstMaxActivePowerImbalance, 3)</td>
                    <td>@Math.Round(secondMaxActivePowerImbalance, 3)</td>
                </tr>
                <tr>
                    <td>Максимальный небаланс по реактивной мощности</td>
                    <td>МВАр</td>
                    <td>@Math.Round(firstMaxReactivePowerImbalance, 3)</td>
                    <td>@Math.Round(secondMaxReactivePowerImbalance, 3)</td>
                </tr>
                <tr>
                    <td>Усредненный суммарный небаланс по активной мощности</td>
                    <td>МВт</td>
                    <td>@Math.Round(firstAverageTotalActivePowerImbalance, 3)</td>
                    <td>@Math.Round(secondAverageTotalActivePowerImbalance, 3)</td>
                </tr>
                <tr>
                    <td>Усредненный суммарный небаланс по реактивной мощности</td>
                    <td>МВАр</td>
                    <td>@Math.Round(firstAverageTotalReactivePowerImbalance, 3)</td>
                    <td>@Math.Round(secondAverageTotalReactivePowerImbalance, 3)</td>
                </tr>
                <tr>
                    <td>Среднее математическое ожидание отклонения измеренного от оцененного</td>
                    <td>(о.е.)</td>
                    <td>@Math.Round(firstAverageDeviation, 3)</td>
                    <td>@Math.Round(secondAverageDeviation, 3)</td>
                </tr>
                <tr>
                    <td>Среднеквадратичное отклонение измеренных значений</td>
                    <td>(о.е.)</td>
                    <td>@Math.Round(firstStandardDeviation, 3)</td>
                    <td>@Math.Round(secondStandardDeviation, 3)</td>
                </tr>
                <tr>
                    <td>Успешность ОС</td>
                    <td>%</td>
                    <td>@GetSuccessRate(firstSetResults.successfulCount, firstSetResults.totalCount)</td>
                    <td>@GetSuccessRate(secondSetResults.successfulCount, secondSetResults.totalCount)</td>
                </tr>
            </tbody>
        </table>

        <!-- Кнопка "Добавить в отчет" -->
        <div class="mt-4 mb-4">
            <button class="btn btn-primary" @onclick="AddToReport">
                Добавить в отчет
            </button>
        </div>

        <!-- Если данные добавлены, показываем кнопку "Сформировать и сохранить отчет" -->
        @if (isDataAddedToReport)
        {
            <div class="mt-4 mb-4">
                <button class="btn btn-primary" @onclick="() => SaveReport(savePath)">
                    Сформировать и сохранить отчет
                </button>
            </div>
        }

    </div>
}

@if (!string.IsNullOrEmpty(errorMessage))
{
    <p class="text-danger" style="margin-top: 10px;">@errorMessage</p>
}

<style>
    .chart-container {
        width: 25vw;
        max-width: 300px; /* Максимальная ширина */
    @* position: relative; *@ margin: 0 auto; /* Центрирование и небольшой отступ */
        display: flex;
        justify-content: center; /* Центрирует график по горизонтали */
        align-items: center; /* Центрирует график по вертикали */
    }

        .chart-container h6 {
            margin: 0; /* Полностью убирает внешние отступы у заголовка */
            padding: 0; /* На случай, если есть внутренние отступы */
            font-size: 1rem; /* Размер шрифта для большей точности */
            text-align: center; /* Центрирование текста заголовка */
        }

        .chart-container canvas {
            width: 100% !important;
            height: 100% !important;
            aspect-ratio: 1; /* Соотношение сторон 1:1 */
        }

    h6 {
        margin-bottom: 5px; /* Уменьшает отступ снизу заголовка */
    }

    .table {
        width: 100%;
        border-collapse: collapse;
    }

        .table th, .table td {
            border: 1px solid #ddd;
            padding: 8px;
        }

        .table th {
            background-color: #f2f2f2;
            text-align: left;
        }
</style>