@page "/reliability-monitor"
@using перенос_бд_на_Web.Models
@using перенос_бд_на_Web.Data
@using перенос_бд_на_Web.Services
@using Microsoft.EntityFrameworkCore
@inject ApplicationContext DbContext
@inject SliceService sliceService
@inject IJSRuntime JS
@inject ReliabilityAnalyzer ReliabilityAnalyzer
@inject PowerImbalanceService PowerImbalanceService
@implements IDisposable

@code {
    private bool isProcessing = false;
    private int successfulCount = 0;
    private int totalCount = 0;
    private int currentProgress = 0;
    // private ElementReference chartElement;
    private ElementReference chartFirstSetRef;
    private ElementReference chartSecondSetRef;
    private CancellationTokenSource cancellationTokenSource;
    private DateTime? startDateTime;
    private DateTime? endDateTime;
    private string errorMessage;
    private bool isChartReady = false;

    private (ActivePowerImbalance imbalance, string sliceName) maxActivePowerImbalance;
    private (ReactivePowerImbalance imbalance, string sliceName) maxReactivePowerImbalance;
    private double averageTotalActivePowerImbalance;
    private double averageTotalReactivePowerImbalance;
    private double averageDeviation;
    private double standardDeviation;

    private string firstSelectedSet;
    private string secondSelectedSet;
    private List<string> uniqueExperimentLabels;


    private (int successfulCount, int totalCount) firstSetResults;
    private (int successfulCount, int totalCount) secondSetResults;

    protected override async Task OnInitializedAsync()
    {
        // Загружаем уникальные значения из колонки experiment_label
        uniqueExperimentLabels = await DbContext.slices
            .Select(s => s.experiment_label)
            .Distinct()
            .ToListAsync();

        firstSelectedSet = uniqueExperimentLabels.FirstOrDefault();
        secondSelectedSet = uniqueExperimentLabels.Skip(1).FirstOrDefault();
    }


    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // Первоначальная настройка, если необходимо
            await DrawChart();
        }
        // else if (isChartReady)
        // {
        //     await DrawChart();
        //     isChartReady = false; // Сбрасываем флаг
        // }
    }

    private async Task ProcessReliabilityData()
    {
        if (startDateTime == null || endDateTime == null)
        {
            errorMessage = "Необходимо указать начальную и конечную дату и время.";
            return;
        }

        isProcessing = true;
        cancellationTokenSource = new CancellationTokenSource();
        errorMessage = null;
        try
        {
            var filePathsFirstSet = await sliceService.GetFilePathsInRangeAsync(startDateTime.Value, endDateTime.Value, firstSelectedSet);
            var filePathsSecondSet = await sliceService.GetFilePathsInRangeAsync(startDateTime.Value, endDateTime.Value, secondSelectedSet);

            if (filePathsFirstSet.Count == 0 || filePathsSecondSet.Count==0)
            {
                errorMessage = "Не найдено файлов в указанном интервале времени.";
                return;
            }

            if (string.IsNullOrEmpty(firstSelectedSet) || string.IsNullOrEmpty(secondSelectedSet))
            {
                errorMessage = "Необходимо выбрать оба набора для сравнения.";
                return;
            }

            // Анализ первого набора
            var firstResult = await ReliabilityAnalyzer.AnalyzeReliabilityData(
                startDateTime.Value,
                endDateTime.Value,
                filePathsFirstSet,
                UpdateProgress,
                cancellationTokenSource.Token
            );

            // Анализ второго набора
            var secondResult = await ReliabilityAnalyzer.AnalyzeReliabilityData(
                startDateTime.Value,
                endDateTime.Value,
                filePathsSecondSet,
                UpdateProgress,
                cancellationTokenSource.Token
            );


            // Сохраняем результаты
            firstSetResults = (firstResult.successfulCount, firstResult.totalCount);
            secondSetResults = (secondResult.successfulCount, secondResult.totalCount);

            // successfulCount = result.successfulCount;
            // totalCount = result.totalCount;

            isChartReady = true; // Флаг для отрисовки диаграмм

            maxActivePowerImbalance = await PowerImbalanceService.GetMaxActivePowerImbalanceAsync();
            maxReactivePowerImbalance = await PowerImbalanceService.GetMaxReactivePowerImbalanceAsync();
            averageTotalActivePowerImbalance = await PowerImbalanceService.GetAverageTotalActivePowerImbalanceAsync();
            averageTotalReactivePowerImbalance = await PowerImbalanceService.GetAverageTotalReactivePowerImbalanceAsync();

            averageDeviation = await CalculateAverageDeviationAsync();
            standardDeviation = await CalculateStandardDeviationAsync();

            isChartReady = true; // Устанавливаем флаг для отображения графика
        }
        catch (Exception ex)
        {
            errorMessage = $"Ошибка при анализе данных: {ex.Message}";
        }
        finally
        {
            isProcessing = false;
            cancellationTokenSource.Dispose();
            cancellationTokenSource = null;
        }

        StateHasChanged(); // Обновляем интерфейс
    }

    private async Task<double> CalculateAverageDeviationAsync()
    {
        return await DbContext.TMValues
            .Select(v => v.IzmerValue - v.OcenValue)
            .AverageAsync();
    }

    private async Task<double> CalculateStandardDeviationAsync()
    {
        var deviations = await DbContext.TMValues
            .Select(v => v.IzmerValue)
            .ToListAsync();

        var mean = deviations.Average();
        var sumOfSquaresOfDifferences = deviations.Select(val => (val - mean) * (val - mean)).Sum();
        return Math.Sqrt(sumOfSquaresOfDifferences / deviations.Count);
    }

    private async Task DrawChart()
    {
        if (firstSetResults.totalCount > 0)
        {
            await JS.InvokeVoidAsync("drawDonutChart", chartFirstSetRef, firstSetResults.successfulCount, firstSetResults.totalCount);
        }

        if (secondSetResults.totalCount > 0)
        {
            await JS.InvokeVoidAsync("drawDonutChart", chartSecondSetRef, secondSetResults.successfulCount, secondSetResults.totalCount);
        }
    }

    private void UpdateProgress(int progress)
    {
        currentProgress = progress;
        InvokeAsync(StateHasChanged);
    }

    public void Dispose()
    {
        cancellationTokenSource?.Cancel();
        cancellationTokenSource?.Dispose();
    }

    private double GetSuccessRate(int successfulCount, int totalCount)
    {
        return totalCount > 0 ? Math.Round((double)successfulCount / totalCount * 100,3) : 0;
    }

}

<PageTitle>Мониторинг надежности</PageTitle>

<h3>Мониторинг надежности</h3>

<!-- Сравнение наборов -->
<div class="d-flex align-items-center mb-3">
    <span class="me-2">Сравнивать набор:</span>
    <select id="firstSet" @bind="firstSelectedSet" class="form-select me-3" style="width: 200px;">
        @if (uniqueExperimentLabels != null && uniqueExperimentLabels.Any())
        {
            @foreach (var label in uniqueExperimentLabels)
            {
                <option value="@label">@label</option>
            }
        }
        else
        {
            <option value="" disabled>Загрузка...</option>
        }
    </select>
    <span class="me-2">с набором:</span>
    <select id="secondSet" @bind="secondSelectedSet" class="form-select" style="width: 200px;">
        @if (uniqueExperimentLabels != null && uniqueExperimentLabels.Any())
        {
            @foreach (var label in uniqueExperimentLabels)
            {
                <option value="@label">@label</option>
            }
        }
        else
        {
            <option value="" disabled>Загрузка...</option>
        }
    </select>
</div>

<!-- Диапазон времени -->
<div class="mb-3">
    <span>Выберите интересующий для анализа диапазон времени:</span>
</div>

<div class="d-flex align-items-center">
    <label for="startDateTime" class="me-2">Начало:</label>
    <input id="startDateTime" type="datetime-local" @bind="startDateTime" class="form-control me-3" style="width: 200px;" />

    <label for="endDateTime" class="me-2">Конец:</label>
    <input id="endDateTime" type="datetime-local" @bind="endDateTime" class="form-control" style="width: 200px;" />
</div>


<div class="mt-3">
    <button class="btn btn-primary" @onclick="ProcessReliabilityData" disabled="@isProcessing">
        Показатели надежности без ЕОТМ
    </button>
</div>

@if (isProcessing)
{
    <div class="progress mt-4">
        <div class="progress-bar" role="progressbar" style="width: @currentProgress%" aria-valuenow="@currentProgress" aria-valuemin="0" aria-valuemax="100">@currentProgress%</div>
    </div>
}

@if (firstSetResults.totalCount > 0 || secondSetResults.totalCount > 0)
{
    <div class="mt-4">
        <h5>Расчетный интервал: от @startDateTime до @endDateTime</h5>
        <div class="row">
            <div class="col-md-6 text-center">
                <h6>@firstSelectedSet</h6>
                <canvas @ref="chartFirstSetRef"></canvas>
                <p>Успешность ОС: @GetSuccessRate(firstSetResults.successfulCount, firstSetResults.totalCount)%</p>
            </div>
            <div class="col-md-6 text-center">
                <h6>@secondSelectedSet</h6>
                <canvas @ref="chartSecondSetRef"></canvas>
                <p>Успешность ОС: @GetSuccessRate(secondSetResults.successfulCount, secondSetResults.totalCount)%</p>
            </div>
        </div>
    </div>
}

@if (!string.IsNullOrEmpty(errorMessage))
{
    <p class="text-danger">@errorMessage</p>
}

@if (maxActivePowerImbalance.imbalance != null || maxReactivePowerImbalance.imbalance != null || averageTotalActivePowerImbalance != 0 || averageTotalReactivePowerImbalance != 0 || averageDeviation != 0 || standardDeviation != 0)
{
    <table class="table mt-4">
        <thead>
            <tr>
                <th>Показатель</th>
                <th>Значение</th>
            </tr>
        </thead>
        <tbody>
            @if (maxActivePowerImbalance.imbalance != null)
            {
                <tr>
                    <td>Максимальный небаланс по активной мощности</td>
                    <td>
                        Наименование среза: @maxActivePowerImbalance.sliceName<br />
                        Наименование узла: @maxActivePowerImbalance.imbalance.name_p<br />
                        Небаланс: @Math.Round(maxActivePowerImbalance.imbalance.p_neb_p,3)
                    </td>
                </tr>
            }
            @if (maxReactivePowerImbalance.imbalance != null)
            {
                <tr>
                    <td>Максимальный небаланс по реактивной мощности</td>
                    <td>
                        Наименование среза: @maxReactivePowerImbalance.sliceName<br />
                        Наименование узла: @maxReactivePowerImbalance.imbalance.name_q<br />
                        Небаланс: @Math.Round(maxReactivePowerImbalance.imbalance.q_neb_q,3)
                    </td>
                </tr>
            }
            @if (averageTotalActivePowerImbalance != 0)
            {
                <tr>
                    <td>Усредненный суммарный небаланс по активной мощности</td>
                    <td>@Math.Round(averageTotalActivePowerImbalance,3)</td>
                </tr>
            }
            @if (averageTotalReactivePowerImbalance != 0)
            {
                <tr>
                    <td>Усредненный суммарный небаланс по реактивной мощности</td>
                    <td>@Math.Round(averageTotalReactivePowerImbalance,3)</td>
                </tr>
            }
            @if (averageDeviation != 0)
            {
                <tr>
                    <td>Среднее по выборке математическое ожидание отклонения измеренного от оцененного</td>
                    <td>@Math.Round(averageDeviation,3)</td>
                </tr>
            }
            @if (standardDeviation != 0)
            {
                <tr>
                    <td>Среднеквадратичное отклонение измеренных значений</td>
                    <td>@Math.Round(standardDeviation,3)</td>
                </tr>
            }
            @* <tr>
                <div>
                    <h3>График 1</h3>
                    <p>Успешность: @GetSuccessRate(firstSetResults.successfulCount, firstSetResults.totalCount)%</p>
                    <!-- Код для графика 1 -->

                    <h3>График 2</h3>
                    <p>Успешность: @GetSuccessRate(secondSetResults.successfulCount, secondSetResults.totalCount)%</p>
                    <!-- Код для графика 2 -->
                </div>
            </tr> *@
        </tbody>
    </table>
}

<style>
    .chart-container {
        width: 25vw;
        height: 25vh;
        position: relative;
    }

        .chart-container canvas {
            width: 100% !important;
            height: 100% !important;
        }

    .table {
        width: 100%;
        border-collapse: collapse;
    }

        .table th, .table td {
            border: 1px solid #ddd;
            padding: 8px;
        }

        .table th {
            background-color: #f2f2f2;
            text-align: left;
        }
</style>