@page "/reliability-monitor"
@using перенос_бд_на_Web.Models
@using перенос_бд_на_Web.Data
@using перенос_бд_на_Web.Services
@using Microsoft.EntityFrameworkCore
@* @inject ApplicationContext DbContext *@
@inject SliceService sliceService
@inject IJSRuntime JS
@inject ReliabilityAnalyzer ReliabilityAnalyzer
@inject PowerImbalanceService PowerImbalanceService
@inject IDbContextFactory<ApplicationContext> ContextFactory
@inject ReportService ReportService
@implements IDisposable

@code {
    private readonly IDbContextFactory<ApplicationContext> _contextFactory;

    private bool isProcessing = false;
    private int successfulCount = 0;
    private int totalCount = 0;
    private int currentProgress = 0;
    // private ElementReference chartElement;
    private ElementReference chartFirstSetRef;
    private ElementReference chartSecondSetRef;
    private CancellationTokenSource cancellationTokenSource;
    private DateTime? startDateTime;
    private DateTime? endDateTime;
    private string errorMessage;
    private bool isChartReady = false;

    private double maxActivePowerImbalance;
    private double maxReactivePowerImbalance;
    private double averageTotalActivePowerImbalance;
    private double averageTotalReactivePowerImbalance;
    private double averageDeviation;
    private double standardDeviation;

    private string firstSelectedSet;
    private string secondSelectedSet;
    private List<string> uniqueExperimentLabels;

    private double firstMaxActivePowerImbalance;
    private double firstMaxReactivePowerImbalance;
    private double firstAverageTotalActivePowerImbalance;
    private double firstAverageTotalReactivePowerImbalance;
    private double firstAverageDeviation;
    private double firstStandardDeviation;

    private double secondMaxActivePowerImbalance;
    private double secondMaxReactivePowerImbalance;
    private double secondAverageTotalActivePowerImbalance;
    private double secondAverageTotalReactivePowerImbalance;
    private double secondAverageDeviation;
    private double secondStandardDeviation;

    private bool isDataAddedToReport = false;

    private (int successfulCount, int totalCount) firstSetResults;
    private (int successfulCount, int totalCount) secondSetResults;

    private int firstSetProgress = 0;
    private int secondSetProgress = 0;

    protected override async Task OnInitializedAsync()
    {
        await using var context = ContextFactory.CreateDbContext();
        // Загружаем уникальные значения из колонки experiment_label
        uniqueExperimentLabels = await context.slices
            .Select(s => s.experiment_label)
            .Distinct()
            .ToListAsync();

        firstSelectedSet = uniqueExperimentLabels.FirstOrDefault();
        secondSelectedSet = uniqueExperimentLabels.Skip(1).FirstOrDefault();
    }


    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            firstRender = false;
        }
        else if (isChartReady && !isProcessing)
        {
            await DrawChart();
            isChartReady = false; // Сбрасываем флаг
        }
    }

    private async Task ProcessReliabilityData()
    {
        if (startDateTime == null || endDateTime == null)
        {
            errorMessage = "Необходимо указать начальную и конечную дату и время.";
            return;
        }

        if (string.IsNullOrEmpty(firstSelectedSet) || string.IsNullOrEmpty(secondSelectedSet))
        {
            errorMessage = "Необходимо выбрать оба набора для сравнения.";
            return;
        }

        isProcessing = true;
        cancellationTokenSource = new CancellationTokenSource();
        errorMessage = null;

        try
        {
            // Параллельная загрузка путей для обоих наборов
            var filePathsTasks = new[]
            {
                sliceService.GetFilePathsInRangeAsync(startDateTime.Value, endDateTime.Value, firstSelectedSet),
                sliceService.GetFilePathsInRangeAsync(startDateTime.Value, endDateTime.Value, secondSelectedSet)
            };
            // // Загрузка путей для наборов
            // var filePathsFirstSet = await sliceService.GetFilePathsInRangeAsync(startDateTime.Value, endDateTime.Value, firstSelectedSet);
            // var filePathsSecondSet = await sliceService.GetFilePathsInRangeAsync(startDateTime.Value, endDateTime.Value, secondSelectedSet);

            var filePathsResults = await Task.WhenAll(filePathsTasks);
            var filePathsFirstSet = filePathsResults[0];
            var filePathsSecondSet = filePathsResults[1];


            if (filePathsFirstSet.Count == 0 || filePathsSecondSet.Count == 0)
            {
                errorMessage = "Не найдено файлов в указанном интервале времени.";
                return;
            }

            // Параллельный анализ данных обоих наборов
            var analyzeTasks = new[]
            {
                Task.Run(() => AnalyzeSetDataAsync(filePathsFirstSet,1)),
                Task.Run(() => AnalyzeSetDataAsync(filePathsSecondSet,2))
            };

            var analyzeResults = await Task.WhenAll(analyzeTasks);
            firstSetResults = analyzeResults[0];
            secondSetResults = analyzeResults[1];

            // Параллельная загрузка метрик обоих наборов
            var loadMetricsTasks = new[]
            {
                Task.Run(() => LoadMetricsAsync(filePathsFirstSet, true)),
                Task.Run(() => LoadMetricsAsync(filePathsSecondSet, false))
            };

            await Task.WhenAll(loadMetricsTasks);

            // // Анализ данных обоих наборов
            // firstSetResults = await AnalyzeSetDataAsync(filePathsFirstSet);
            // // Загрузка метрик первого набора
            // await LoadMetricsAsync(filePathsFirstSet, true);
            // secondSetResults = await AnalyzeSetDataAsync(filePathsSecondSet);
            // // Загрузка метрик второго набора
            // await LoadMetricsAsync(filePathsSecondSet, false);

            isChartReady = true; // Флаг для отрисовки диаграмм
        }
        catch (Exception ex)
        {
            errorMessage = $"Ошибка при анализе данных: {ex.Message}";
        }
        finally
        {
            isProcessing = false;
            cancellationTokenSource.Dispose();
            cancellationTokenSource = null;
        }

        StateHasChanged(); // Обновление интерфейса
    }


    private async Task LoadMetricsAsync(IEnumerable<string> slicePaths, bool isFirstSet)
    {
        // Обращение к PowerImbalanceService для расчета метрик
        await using var context = ContextFactory.CreateDbContext();

        var metrics = await PowerImbalanceService.CalculateMetricsAsync(slicePaths);

        if (isFirstSet)
        {
            firstMaxActivePowerImbalance = metrics.MaxActivePowerImbalance;
            firstMaxReactivePowerImbalance = metrics.MaxReactivePowerImbalance;
            firstAverageTotalActivePowerImbalance = metrics.AverageTotalActivePowerImbalance;
            firstAverageTotalReactivePowerImbalance = metrics.AverageTotalReactivePowerImbalance;

            firstAverageDeviation = await CalculateAverageDeviationAsync(slicePaths);
            firstStandardDeviation = await CalculateStandardDeviationAsync(slicePaths);
        }
        else
        {
            secondMaxActivePowerImbalance = metrics.MaxActivePowerImbalance;
            secondMaxReactivePowerImbalance = metrics.MaxReactivePowerImbalance;
            secondAverageTotalActivePowerImbalance = metrics.AverageTotalActivePowerImbalance;
            secondAverageTotalReactivePowerImbalance = metrics.AverageTotalReactivePowerImbalance;

            secondAverageDeviation = await CalculateAverageDeviationAsync(slicePaths);
            secondStandardDeviation = await CalculateStandardDeviationAsync(slicePaths);
        }
    }

    private async Task<(int successfulCount, int totalCount)> AnalyzeSetDataAsync(List<string> filePaths, int setNumber)
    {
        var result = await ReliabilityAnalyzer.AnalyzeReliabilityData(
        startDateTime.Value,
        endDateTime.Value,
        filePaths,
        progress => UpdateProgress(setNumber, progress),
        cancellationTokenSource.Token);

        return (result.successfulCount, result.totalCount);
    }

    private async Task<double> CalculateAverageDeviationAsync(IEnumerable<string> slicePaths)
    {
        await using var context = ContextFactory.CreateDbContext();

        // Шаг 1: Фильтрация данных через связь TMValues и Slices
        var filteredData = context.TMValues
            .Join(context.slices,           // Присоединяем таблицу Slices
                  tm => tm.SliceID,           // Поле связи из TMValues
                  slice => slice.SliceID,          // Поле связи из Slices
                  (tm, slice) => new { tm, slice }) // Результат - объединённые записи
            .Where(joined => slicePaths.Contains(joined.slice.SlicePath)) // Фильтрация по путям
            .Select(joined => joined.tm);     // Возвращаем только записи TMValues

        // Шаг 2: Группировка по уникальным сочетаниям IndexTM и Id1
        var averageDeviations = await filteredData
            .GroupBy(v => new { v.IndexTM, v.Id1 }) // Группировка по IndexTM и Id1
            .Select(group => group.Average(v => v.IzmerValue - v.OcenValue)) // Среднее отклонение для каждой группы
            .ToListAsync();

        // Шаг 3: Рассчитываем общее среднее: сумма всех средних значений / количество уникальных групп
        double totalSum = averageDeviations.Sum(); // Суммируем все средние значения
        int groupCount = averageDeviations.Count; // Количество уникальных групп

        // Шаг 4: Возвращаем итоговое значение
        return groupCount > 0 ? totalSum / groupCount : 0.0; // Проверка деления на 0
    }

    private async Task<double> CalculateStandardDeviationAsync(IEnumerable<string> slicePaths)
    {
        await using var context = ContextFactory.CreateDbContext();
        var query = context.TMValues
            .Join(context.slices,
                  tm => tm.SliceID,
                  slice => slice.SliceID,
                  (tm, slice) => new { tm.IzmerValue, slice.SlicePath })
            .Where(joined => slicePaths.Contains(joined.SlicePath))
            .Select(joined => joined.IzmerValue);

        // Среднее значение
        var mean = await query.AverageAsync();

        // Сумма квадратов отклонений
        var sumOfSquaresOfDifferences = await query
            .Select(val => (val - mean) * (val - mean))
            .SumAsync();

        // Количество значений
        var count = await query.CountAsync();

        return count > 0 ? Math.Sqrt(sumOfSquaresOfDifferences / count) : 0.0;
    }

    private async Task DrawChart()
    {
        if (firstSetResults.totalCount > 0)
        {
            await JS.InvokeVoidAsync("drawDonutChart", chartFirstSetRef, firstSetResults.successfulCount, firstSetResults.totalCount);
        }

        if (secondSetResults.totalCount > 0)
        {
            await JS.InvokeVoidAsync("drawDonutChart", chartSecondSetRef, secondSetResults.successfulCount, secondSetResults.totalCount);
        }
    }

    private void UpdateProgress(int setNumber, int progress)
    {
        if (setNumber == 1)
            firstSetProgress = progress;
        else
            secondSetProgress = progress;

        // Рассчитываем общий прогресс как среднее арифметическое
        currentProgress = (firstSetProgress + secondSetProgress) / 2;
        InvokeAsync(StateHasChanged);
    }

    public void Dispose()
    {
        cancellationTokenSource?.Cancel();
        cancellationTokenSource?.Dispose();
    }

    private double GetSuccessRate(int successfulCount, int totalCount)
    {
        return totalCount > 0 ? Math.Round((double)successfulCount / totalCount * 100, 3) : 0;
    }

    private async Task AddToReport()
    {
        // Проверка наличия данных перед вызовом сервиса
        if (firstSetResults.totalCount > 0 && secondSetResults.totalCount > 0)
        {
            await ReportService.AddToReport(
            firstSelectedSet, secondSelectedSet,
            firstMaxActivePowerImbalance, secondMaxActivePowerImbalance,
            firstMaxReactivePowerImbalance, secondMaxReactivePowerImbalance,
            firstAverageTotalActivePowerImbalance, secondAverageTotalActivePowerImbalance,
            firstAverageTotalReactivePowerImbalance, secondAverageTotalReactivePowerImbalance,
            firstAverageDeviation, secondAverageDeviation,
            firstStandardDeviation, secondStandardDeviation,
            GetSuccessRate(firstSetResults.successfulCount, firstSetResults.totalCount),
            GetSuccessRate(secondSetResults.successfulCount, secondSetResults.totalCount),
            startDateTime, endDateTime
            );
        }
        // Устанавливаем флаг, что данные добавлены
        isDataAddedToReport = true;
    }

    private async Task SaveReport()
    {
        try
        {
            // Вызов метода для сохранения отчета
            await ReportService.SaveReportAsync();
        }
        catch (Exception ex)
        {
            // Логирование ошибки
            Console.WriteLine($"Ошибка при сохранении отчета: {ex.Message}");
        }
    }

}

<PageTitle>Мониторинг надежности</PageTitle>

<h3>Мониторинг надежности</h3>

<!-- Сравнение наборов -->
<div class="d-flex align-items-center mb-3">
    <span class="me-2">Сравнивать набор:</span>
    <select id="firstSet" @bind="firstSelectedSet" class="form-select me-3" style="width: 200px;">
        @if (uniqueExperimentLabels != null && uniqueExperimentLabels.Any())
        {
            @foreach (var label in uniqueExperimentLabels)
            {
                <option value="@label">@label</option>
            }
        }
        else
        {
            <option value="" disabled>Загрузка...</option>
        }
    </select>
    <span class="me-2">с набором:</span>
    <select id="secondSet" @bind="secondSelectedSet" class="form-select" style="width: 200px;">
        @if (uniqueExperimentLabels != null && uniqueExperimentLabels.Any())
        {
            @foreach (var label in uniqueExperimentLabels)
            {
                <option value="@label">@label</option>
            }
        }
        else
        {
            <option value="" disabled>Загрузка...</option>
        }
    </select>
</div>

<!-- Диапазон времени -->
<div class="mb-3">
    <span>Выберите интересующий для анализа диапазон времени:</span>
</div>

<div class="d-flex align-items-center">
    <label for="startDateTime" class="me-2">Начало:</label>
    <input id="startDateTime" type="datetime-local" @bind="startDateTime" class="form-control me-3" style="width: 200px;" />

    <label for="endDateTime" class="me-2">Конец:</label>
    <input id="endDateTime" type="datetime-local" @bind="endDateTime" class="form-control" style="width: 200px;" />
</div>

<!-- Кнопка -->
<div class="mt-3">
    <button class="btn btn-primary" @onclick="ProcessReliabilityData" disabled="@isProcessing">
        Показатели надежности без ЕОТМ
    </button>
</div>

@if (isProcessing)
{
    <div class="progress mt-4">
        <div class="progress-bar" role="progressbar" style="width: @currentProgress%"
             aria-valuenow="@currentProgress" aria-valuemin="0" aria-valuemax="100">
            @currentProgress%
        </div>
    </div>
}

@if (firstSetResults.totalCount > 0 && secondSetResults.totalCount > 0)
{
    <div class="mt-4 text-center">
        <h5>Расчетный интервал: от @startDateTime до @endDateTime</h5>
        <div class="row justify-content-center">
            <!-- Первый график -->
            <div class="col-md-6">
                <h6>@firstSelectedSet</h6>
                <div class="chart-container">
                    <canvas @ref="chartFirstSetRef"></canvas>
                </div>
                <p>Успешность ОС: @GetSuccessRate(firstSetResults.successfulCount, firstSetResults.totalCount)%</p>
            </div>
            <!-- Второй график -->
            <div class="col-md-6">
                <h6>@secondSelectedSet</h6>
                <div class="chart-container">
                    <canvas @ref="chartSecondSetRef"></canvas>
                </div>
                <p>Успешность ОС: @GetSuccessRate(secondSetResults.successfulCount, secondSetResults.totalCount)%</p>
            </div>
        </div>

        <table class="table mt-4">
            <thead>
                <tr>
                    <th>Показатель</th>
                    <th>Единицы измерения</th>
                    <th>@firstSelectedSet</th>
                    <th>@secondSelectedSet</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Максимальный небаланс по активной мощности</td>
                    <td>МВт</td>
                    <td>@Math.Round(firstMaxActivePowerImbalance, 3)</td>
                    <td>@Math.Round(secondMaxActivePowerImbalance, 3)</td>
                </tr>
                <tr>
                    <td>Максимальный небаланс по реактивной мощности</td>
                    <td>МВАр</td>
                    <td>@Math.Round(firstMaxReactivePowerImbalance, 3)</td>
                    <td>@Math.Round(secondMaxReactivePowerImbalance, 3)</td>
                </tr>
                <tr>
                    <td>Усредненный суммарный небаланс по активной мощности</td>
                    <td>МВт</td>
                    <td>@Math.Round(firstAverageTotalActivePowerImbalance, 3)</td>
                    <td>@Math.Round(secondAverageTotalActivePowerImbalance, 3)</td>
                </tr>
                <tr>
                    <td>Усредненный суммарный небаланс по реактивной мощности</td>
                    <td>МВАр</td>
                    <td>@Math.Round(firstAverageTotalReactivePowerImbalance, 3)</td>
                    <td>@Math.Round(secondAverageTotalReactivePowerImbalance, 3)</td>
                </tr>
                <tr>
                    <td>Среднее математическое ожидание отклонения измеренного от оцененного</td>
                    <td>(о.е.)</td>
                    <td>@Math.Round(firstAverageDeviation, 3)</td>
                    <td>@Math.Round(secondAverageDeviation, 3)</td>
                </tr>
                <tr>
                    <td>Среднеквадратичное отклонение измеренных значений</td>
                    <td>(о.е.)</td>
                    <td>@Math.Round(firstStandardDeviation, 3)</td>
                    <td>@Math.Round(secondStandardDeviation, 3)</td>
                </tr>
                <tr>
                    <td>Успешность ОС</td>
                    <td>%</td>
                    <td>@GetSuccessRate(firstSetResults.successfulCount, firstSetResults.totalCount)</td>
                    <td>@GetSuccessRate(secondSetResults.successfulCount, secondSetResults.totalCount)</td>
                </tr>
            </tbody>
        </table>

        <!-- Кнопка "Добавить в отчет" -->
        <div class="mt-4 mb-4">
            <button class="btn btn-success" @onclick="AddToReport">
                Добавить в отчет
            </button>
        </div>

        <!-- Если данные добавлены, показываем кнопку "Сформировать и сохранить отчет" -->
        @if (isDataAddedToReport)
        {
            <div class="mt-4 mb-4">
                <button class="btn btn-primary" @onclick="SaveReport">
                    Сформировать и сохранить отчет
                </button>
            </div>
        }

    </div>
}

@if (!string.IsNullOrEmpty(errorMessage))
{
    <p class="text-danger">@errorMessage</p>
}

<style>
    .chart-container {
        width: 25vw;
        max-width: 300px; /* Максимальная ширина */
    @* position: relative; *@ margin: 0 auto; /* Центрирование и небольшой отступ */
        display: flex;
        justify-content: center; /* Центрирует график по горизонтали */
        align-items: center; /* Центрирует график по вертикали */
    }

        .chart-container h6 {
            margin: 0; /* Полностью убирает внешние отступы у заголовка */
            padding: 0; /* На случай, если есть внутренние отступы */
            font-size: 1rem; /* Размер шрифта для большей точности */
            text-align: center; /* Центрирование текста заголовка */
        }

        .chart-container canvas {
            width: 100% !important;
            height: 100% !important;
            aspect-ratio: 1; /* Соотношение сторон 1:1 */
        }

    h6 {
        margin-bottom: 5px; /* Уменьшает отступ снизу заголовка */
    }

    .table {
        width: 100%;
        border-collapse: collapse;
    }

        .table th, .table td {
            border: 1px solid #ddd;
            padding: 8px;
        }

        .table th {
            background-color: #f2f2f2;
            text-align: left;
        }
</style>