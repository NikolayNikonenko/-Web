@page "/nedostovernost"
@using перенос_бд_на_Web.Models
@using Microsoft.EntityFrameworkCore
@using перенос_бд_на_Web.Models
@using перенос_бд_на_Web.Data
@using перенос_бд_на_Web.Services
@using Microsoft.EntityFrameworkCore
@inject SliceService sliceService
@inject ApplicationContext _context
@inject CorrData corr
@inject IJSRuntime JS

<PageTitle>Выявленные недостоверности ТМ</PageTitle>

<style>
    .status-dostovernaya {
        background-color: lightgreen;
    }

    .status-somnitelnaya {
        background-color: lightyellow;
    }

    .status-nedostovernaya {
        background-color: lightcoral;
    }
</style>

@code {
    private List<NedostovernayaTM> tm = new List<NedostovernayaTM>();
    private List<NedostovernayaTM> filteredTm = new List<NedostovernayaTM>();
    public List<TMValues> filteredTMValues = new List<TMValues>();
    private string currentSortColumn;
    private bool isAscending = true;
    private string searchTerm = string.Empty;
    private bool showSearch = false;
    private bool showChartInput = false;
    private bool showChart = false;
    private string tmIndexInput = string.Empty;
    private List<TMValues> chartData = new List<TMValues>();
    private bool chartDataAvailable = false;
    private ElementReference chartElement;
    private DateTime? startDate;
    private DateTime? endDate;
    private bool showTimeIntervalInput = false;
    private List<NedostovernayaTM> tmData = new List<NedostovernayaTM>();
    private bool showThinningInput = false; // Показывать ли поле для ввода интервала прореживания
    private int pruningInterval = 1; // Интервал прореживания по умолчанию
    private List<TMValues> chartSourceData = new List<TMValues>();
    //private int currentProgress =0;
    //private bool isStatusBarVisible = false;

    protected override async Task OnInitializedAsync()
    {
        await LoadData();
    }

    // Метод для обновления прогресса
    // private void UpdateProgress(int progress)
    // {
    //     currentProgress = progress;
    //     StateHasChanged(); // Обновляем состояние компонента для рендеринга изменений
    // }

    // private void SetStatusBarVisible(bool isVisible)
    // {
    //     isStatusBarVisible = isVisible;
    // }

    private async Task LoadData()
    {
        //using (var context = new ApplicationContext()) // Передайте нужные параметры
        //{
        try
        {
            // Загрузка данных о недостоверностях
            tm = await _context.tm.AsNoTracking().ToListAsync();
            filteredTm = tm;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error fetching data: {ex.Message}");
        }
        //}
    }

    private void SortData(string column)
    {
        if (currentSortColumn == column)
        {
            isAscending = !isAscending;
        }
        else
        {
            currentSortColumn = column;
            isAscending = true;
        }

        filteredTm = column switch
        {
            nameof(NedostovernayaTM.ID) => isAscending ? filteredTm.OrderBy(t => t.ID).ToList() : filteredTm.OrderByDescending(t => t.ID).ToList(),
            nameof(NedostovernayaTM.IndexTm) => isAscending ? filteredTm.OrderBy(t => t.IndexTm).ToList() : filteredTm.OrderByDescending(t => t.IndexTm).ToList(),
            nameof(NedostovernayaTM.CorrTm) => isAscending ? filteredTm.OrderBy(t => t.CorrTm).ToList() : filteredTm.OrderByDescending(t => t.CorrTm).ToList(),
            nameof(NedostovernayaTM.Status) => isAscending ? filteredTm.OrderBy(t => t.Status).ToList() : filteredTm.OrderByDescending(t => t.Status).ToList(),
            nameof(NedostovernayaTM.MaxLagranj) => isAscending ? filteredTm.OrderBy(t => t.MaxLagranj).ToList() : filteredTm.OrderByDescending(t => t.MaxLagranj).ToList(),
            nameof(NedostovernayaTM.AvgLagranj) => isAscending ? filteredTm.OrderBy(t => t.AvgLagranj).ToList() : filteredTm.OrderByDescending(t => t.AvgLagranj).ToList(),
            _ => filteredTm
        };
    }

    private void SearchData()
    {
        if (string.IsNullOrEmpty(searchTerm))
        {
            filteredTm = tm;
        }
        else
        {
            filteredTm = tm.Where(t => t.IndexTm.ToString().Contains(searchTerm, StringComparison.OrdinalIgnoreCase)).ToList();
        }
        SortData(currentSortColumn);
    }

    private void ToggleSearch()
    {
        showSearch = !showSearch;
        if (!showSearch)
        {
            searchTerm = string.Empty;
            SearchData();
        }
    }

    private void ResetSearch()
    {
        searchTerm = string.Empty;
        filteredTm = tm;
        SortData(currentSortColumn);
    }

    private void ShowChartInput()
    {
        showChartInput = true;
        showChart = false; // Скрыть график при показе ввода для нового графика
    }

    private void HideChart()
    {
        showChart = false;
        chartDataAvailable = false;
    }

    private string GetYAxisLabel(string privyazka)
    {
        return privyazka switch
        {
            "U" => "U, кВ",
            "Pнач" or "Pкон" or "P_ген-р" or "Pген" or "Pнаг" => "P, МВт",
            "Qнач" or "Qкон" or "Q_ген-р" or "Qген" or "Qнаг" => "Q, МВар",
            _ => "Значения"
        };
    }


    private async Task GenerateChart()
    {
        if (double.TryParse(tmIndexInput, out double tmIndex))
        {
            // Шаг 1: Извлекаем данные по IndexTM
            IQueryable<TMValues> query = _context.TMValues.Where(tv => tv.IndexTM == tmIndex);

            // Извлекаем данные без фильтрации по дате
            var tmValuesList = await query.ToListAsync();

            Console.WriteLine($"Всего записей: {tmValuesList.Count}");

            // Шаг 2: Фильтрация по временному интервалу
            if (startDate.HasValue && endDate.HasValue)
            {
                chartData = tmValuesList
                    .Where(tv =>
                    {
                        // Разделяем строку по символу "_", чтобы получить часы, минуты и секунды
                        var timeParts = tv.NumberOfSrez.Split('_');
                        if (timeParts.Length == 3 &&
                            int.TryParse(timeParts[0], out int hours) &&
                            int.TryParse(timeParts[1], out int minutes) &&
                            int.TryParse(timeParts[2], out int seconds))
                        {
                            // Преобразуем в TimeSpan для сравнения
                            var parsedTime = new TimeSpan(hours, minutes, seconds);
                            var startTime = startDate.Value.TimeOfDay;
                            var endTime = endDate.Value.TimeOfDay;

                            Console.WriteLine($"Parsed TimeSpan: {parsedTime}, StartTime: {startTime}, EndTime: {endTime}");

                            // Сравнение времени без учета даты
                            return parsedTime >= startTime && parsedTime <= endTime;
                        }
                        else
                        {
                            Console.WriteLine($"Ошибка преобразования времени: {tv.NumberOfSrez}");
                            return false;
                        }
                    })
                    .ToList();
            }
            else
            {
                chartData = tmValuesList;
            }

            // Шаг 3: Применение прореживания (если задано)
            if (pruningInterval > 0)
            {
                // Сортируем данные перед прореживанием, чтобы сохранить порядок срезов
                chartData = chartData
                    .OrderBy(tv => tv.NumberOfSrez)
                    .ThenBy(tv => tv.OrderIndex)  // Убедимся, что данные сортируются по порядку
                    .Where((tv, index) => index % pruningInterval == 0)  // Применяем прореживание
                    .ToList();
            }
            else
            {
                // Просто сортируем данные, если интервал прореживания не задан
                chartData = chartData
                    .OrderBy(tv => tv.NumberOfSrez)
                    .ThenBy(tv => tv.OrderIndex)
                    .ToList();
            }

            // Проверяем наличие данных
            if (!chartData.Any())
            {
                Console.WriteLine($"Нет данных для IndexTM: {tmIndex}");
                chartDataAvailable = false;
                return;
            }

            // Шаг 4: Извлечение дополнительных данных (если необходимо)
            var DataInTm = await _context.tm
                .Where(tm => tm.IndexTm == tmIndex)
                .ToListAsync();

            // Устанавливаем флаг доступности данных для графика
            chartDataAvailable = true;
            showChart = true;

            // Формируем заголовок и метку оси Y для графика
            string chartTitle = $"Индекс ТМ: {chartData[0].IndexTM}, Наименование: {chartData[0].NameTM}";
            string yAxisLabel = GetYAxisLabel(chartData[0].Privyazka);

            // Убедитесь, что элемент доступен перед вызовом JS
            await Task.Delay(100);
            StateHasChanged();

            // Шаг 5: Вызов JavaScript для генерации графика
            try
            {
                Console.WriteLine($"Прореженные данные для графика: {chartData.Count}");
                foreach (var item in chartData)
                {
                    Console.WriteLine($"IndexTM: {item.IndexTM}, Время среза: {item.NumberOfSrez}, Id1: {item.Id1}");
                }


                await JS.InvokeVoidAsync("generateChart", chartElement, chartData, DataInTm, chartTitle, yAxisLabel);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Ошибка вызова JavaScript: {ex.Message}");
            }
        }
        else
        {
            chartDataAvailable = false;
            Console.WriteLine("Некорректный ввод номера ТМ.");
        }
    }

    private string GetRowClass(string status)
    {
        return status switch
        {
            "Достоверная" => "status-dostovernaya",
            "Сомнительная" => "status-somnitelnaya",
            "Недостоверная" => "status-nedostovernaya",
            _ => string.Empty
        };
    }
    private async Task ApplyTimeIntervalFilter(bool isThinning = false)
    {
        if (startDate.HasValue && endDate.HasValue)
        {
            await FilterByTimeInterval(isThinning);
        }
        else
        {
            await RetrieveAllData(isThinning);
        }
    }

    private async Task FilterByTimeInterval(bool isThinning)
    {
        var filePaths = await sliceService.GetFilePathsInRangeAsync(startDate.Value, endDate.Value);

        if (!filePaths.Any())
        {
            Console.WriteLine("Нет найденных путей файлов для заданного временного интервала.");
            return;
        }

        var sliceIdsInRange = await _context.slices
            .Where(s => filePaths.Contains(s.SlicePath))
            .Select(s => s.SliceID)
            .ToListAsync();

        if (!sliceIdsInRange.Any())
        {
            Console.WriteLine("Нет идентификаторов срезов для заданных путей файлов.");
            return;
        }

        filteredTMValues = await _context.TMValues
            .Where(t => sliceIdsInRange.Contains(t.SliceID))
            .ToListAsync();

        if (!filteredTMValues.Any())
        {
            Console.WriteLine("filteredTMValues пуст после фильтрации.");
            return;
        }

        UpdateChartSourceData(filteredTMValues);

        if (isThinning)
        {
            ApplyThinning();
        }
    }

    private async Task RetrieveAllData(bool isThinning)
    {
        filteredTMValues = await _context.TMValues.ToListAsync();
        UpdateChartSourceData(filteredTMValues);

        if (!filteredTMValues.Any())
        {
            Console.WriteLine("Нет данных в TMValues.");
            return;
        }

        if (isThinning)
        {
            ApplyThinning();
        }
    }

    private void UpdateChartSourceData(List<TMValues> data)
    {
        chartSourceData = data.ToList();
        Console.WriteLine($"Найдено {data.Count} значений после фильтрации по времени.");
    }

    private void ApplyThinning()
    {
        if (pruningInterval <= 0)
        {
            Console.WriteLine("thinningInterval должен быть больше 0.");
            return;
        }

        filteredTMValues = filteredTMValues
            .Where((t, index) => index % pruningInterval == 0)
            .ToList();

        UpdateChartSourceData(filteredTMValues);
        Console.WriteLine($"Прореживание данных: осталось {filteredTMValues.Count} значений.");
    }

}

@if (showTimeIntervalInput)
{
    <div class="mb-3">
        <label>Начало временного промежутка:</label>
        <input type="datetime-local" @bind="startDate" class="form-control" />
        <label>Конец временного промежутка:</label>
        <input type="datetime-local" @bind="endDate" class="form-control" />

        @if (showThinningInput)
        {
            <div class="mb-3">
                <label>Интервал прореживания:</label>
                <input type="number" @bind="pruningInterval" min="1" class="form-control" />
            </div>
        }

        <div class="mt-2">
            <button @onclick="() => ApplyTimeIntervalFilter(false)" class="btn btn-primary me-2">Применить фильтр</button>
            <button @onclick="() => ApplyTimeIntervalFilter(true)" class="btn btn-secondary">Прореживать данные</button>
        </div>
    </div>
}

<h2>Выявленные недостоверности ТМ</h2>

<button @onclick="() => showTimeIntervalInput = !showTimeIntervalInput" class="btn btn-primary mt-2">
    @(showTimeIntervalInput ? "Скрыть выбор времени" : "Показать выбор времени")
</button>

<button @onclick="() => showThinningInput = !showThinningInput" class="btn btn-primary mt-2">
    @(showThinningInput ? "Скрыть интервал прореживания" : "Задать интервал прореживания")
</button>


<!-- Кнопка для запуска расчёта -->
<button @onclick="OnCalculateCorrelation" class="btn btn-primary mt-2" disabled="@isCalculating">
    Рассчитать корреляцию
</button>

<!-- Кнопка для остановки расчёта -->
<button @onclick="OnStopCalculation" class="btn btn-danger mt-2" disabled="@(isCalculating == false)">
    Остановить расчет
</button>

@if (isStatusBarVisible)
{
    <!-- Прогресс-бар -->
    <div class="progress mt-4">
        <div class="progress-bar" role="progressbar" style="width: @currentProgress%" aria-valuenow="@currentProgress" aria-valuemin="0" aria-valuemax="100">
            @currentProgress%
        </div>
    </div>
}

@code {
    private bool isCalculating = false;
    private bool isStatusBarVisible = false;
    private int currentProgress = 0;
    private CancellationTokenSource cancellationTokenSource;

    private async Task OnCalculateCorrelation()
    {
        if (isCalculating) return; // Если расчёт уже запущен, новый не начинаем

        // Инициализация состояния
        isCalculating = true;
        isStatusBarVisible = true; // Показываем статусбар
        cancellationTokenSource = new CancellationTokenSource(); // Инициализация токена отмены

        StateHasChanged(); // Обновляем UI

        try
        {
            await corr.CalculationCorrelation(
                filteredTMValues,       // передаем отфильтрованные значения
                UpdateProgress,         // метод для обновления прогресса
                SetStatusBarVisible,     // метод для управления видимостью статусбара
                startDate,              // начальная дата
                endDate,                // конечная дата
                false,
                1,
                cancellationTokenSource.Token // передаем токен отмены
            );
        }
        catch (OperationCanceledException)
        {
            Console.WriteLine("Расчет был остановлен.");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Ошибка при расчете корреляции: {ex.Message}");
        }
        finally
        {
            isCalculating = false;  // Завершаем расчёт
            isStatusBarVisible = false;  // Скрываем статусбар
            StateHasChanged(); // Обновляем UI
        }
    }

    private void OnStopCalculation()
    {
        if (isCalculating && cancellationTokenSource != null)
        {
            cancellationTokenSource.Cancel(); // Отменяем текущую задачу
            isCalculating = false; // Останавливаем процесс расчёта
        }
    }

    private void SetStatusBarVisible(bool isVisible)
    {
        isStatusBarVisible = isVisible; // Устанавливаем видимость статусбара
        StateHasChanged(); // Обновляем UI
    }

    private void UpdateProgress(int progress)
    {
        currentProgress = progress; // Обновляем прогресс
        StateHasChanged(); // Обновляем UI
    }
}



<button @onclick="ShowChartInput" class="btn btn-primary mt-2">Показать график корреляции</button>

@if (showSearch)
{
    <div class="mb-3">
        <input @bind="searchTerm" placeholder="Поиск по Index TM" class="form-control" />
        <button @onclick="SearchData" class="btn btn-primary mt-2">Искать</button>
        <button @onclick="ResetSearch" class="btn btn-secondary mt-2 ml-2">Сбросить</button>
    </div>
}

@if (showChartInput)
{
    <div class="mb-3">
        <input @bind="tmIndexInput" placeholder="Введите номер ТМ" class="form-control" />
        <button @onclick="GenerateChart" class="btn btn-primary mt-2">Построить график</button>
    </div>
}

@if (chartDataAvailable && showChart)
{
    <div class="mt-4">
        <button @onclick="HideChart" class="btn btn-secondary mb-2">Закрыть график</button>
        <canvas id="chart" width="400" height="200" @ref="chartElement"></canvas>
    </div>
}

@if (filteredTm == null || !filteredTm.Any())
{
    <p>Нет данных для отображения.</p>
}
else
{
    <table class="table table-bordered">
        <thead>
            <tr>
                <th @onclick="() => SortData(nameof(NedostovernayaTM.ID))">
                    Идентификатор @(currentSortColumn == nameof(NedostovernayaTM.ID) ? (isAscending ? "▲" : "▼") : "")
                </th>
                <th>
                    <span @onclick="() => SortData(nameof(NedostovernayaTM.IndexTm))" style="cursor:pointer;">
                        Индекс ТМ @(currentSortColumn == nameof(NedostovernayaTM.IndexTm) ? (isAscending ? "▲" : "▼") : "")
                    </span>
                    <button @onclick="ToggleSearch" class="btn btn-link" style="padding:0; margin-left:5px;">
                        🔍
                    </button>
                </th>
                <th @onclick="() => SortData(nameof(NedostovernayaTM.CorrTm))">
                    Коэффициент корреляции @(currentSortColumn == nameof(NedostovernayaTM.CorrTm) ? (isAscending ? "▲" : "▼") : "")
                </th>
                <th @onclick="() => SortData(nameof(NedostovernayaTM.Status))">
                    Статус @(currentSortColumn == nameof(NedostovernayaTM.Status) ? (isAscending ? "▲" : "▼") : "")
                </th>
                <th @onclick="() => SortData(nameof(NedostovernayaTM.MaxLagranj))">
                    Максимальное значение лагранжиана @(currentSortColumn == nameof(NedostovernayaTM.MaxLagranj) ? (isAscending ? "▲" : "▼") : "")
                </th>
                <th @onclick="() => SortData(nameof(NedostovernayaTM.AvgLagranj))">
                    Среднее значение лагранжиана @(currentSortColumn == nameof(NedostovernayaTM.AvgLagranj) ? (isAscending ? "▲" : "▼") : "")
                </th>
            </tr>
        </thead>
        <tbody>
            @foreach (var telemetry in filteredTm)
            {
                <tr class="@GetRowClass(telemetry.Status)">
                    <td>@telemetry.ID</td>
                    <td>@telemetry.IndexTm</td>
                    <td>@telemetry.CorrTm</td>
                    <td>@telemetry.Status</td>
                    <td>@telemetry.MaxLagranj</td>
                    <td>@telemetry.AvgLagranj</td>
                </tr>
            }
        </tbody>
    </table>
}

