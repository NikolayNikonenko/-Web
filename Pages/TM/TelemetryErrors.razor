@page "/nedostovernost"
@using перенос_бд_на_Web.Models
@using Microsoft.EntityFrameworkCore
@using перенос_бд_на_Web.Models
@using перенос_бд_на_Web.Data
@using перенос_бд_на_Web.Services
@using Microsoft.EntityFrameworkCore
@inject SliceService sliceService
@inject ActionService ActionService
@inject TelemetryMonitoringService MonitoringService
@inject ValidationService ValidationService
@inject ApplicationContext _context
@inject CorrData corr
@inject IJSRuntime JS

<PageTitle>Выявленные недостоверности ТМ</PageTitle>

<style>
    /* Входные данные */
    .input-status-dostovernaya {
        background-color: lightgreen !important;
    }

    .input-status-somnitelnaya {
        background-color: lightyellow !important;
    }

    .input-status-nedostovernaya {
        background-color: lightcoral !important;
    }

    /* Эксперименты */
    .experiment-status-dostovernaya {
        background-color: lightgreen !important;
    }

    .experiment-status-somnitelnaya {
        background-color: lightyellow !important;
    }

    .experiment-status-nedostovernaya {
        background-color: lightcoral !important;
    }
</style>

@code {
    private List<NedostovernayaTM> tm = new List<NedostovernayaTM>();
    private List<NedostovernayaTM> filteredTm = new List<NedostovernayaTM>();
    public List<TMValues> filteredTMValues = new List<TMValues>();
    private List<TMValues> originalTMValues; // Исходный набор данных
    private string currentSortColumn;
    private bool isAscending = true;
    private string searchTerm = string.Empty;
    private bool showSearch = false;
    private bool showChartInput = false;
    private bool showChart = false;
    private string tmIndexInput = string.Empty;
    private List<TMValues> chartData = new List<TMValues>();
    private bool chartDataAvailable = false;
    private ElementReference chartElement;
    private DateTime? startDate;
    private DateTime? endDate;
    private bool showTimeIntervalInput = false;
    private List<NedostovernayaTM> tmData = new List<NedostovernayaTM>();
    private bool showThinningInput = false; // Показывать ли поле для ввода интервала прореживания
    private int pruningInterval = 1; // Интервал прореживания по умолчанию
    private List<TMValues> chartSourceData = new List<TMValues>();
    public bool IsDropdownVisible { get; set; }  // Новое свойство
    private NedostovernayaTM selectedTelemetry; // Хранит выбранный элемент для отображения действий
    private string selectedAction; // Хранит выбранное действие
    private bool showChangeList = false;
    private List<VerificationAction> selectedActions = new();
    private bool showModal = false;
    private bool isActionConfirmed = false;
    private bool isTrackingOptionsVisible;
    private List<TMValues> filteredTMValuesAfterValidation = new List<TMValues>();

    private bool showManualMonitorModal=false;
    private string manualTMInput;
    private string errorMessage;

    private List<TMValues> selectedTMValues = new();
    private List<TMValues> manualTMValues = new();

    private bool isManualInput = false;

    private List<int> manualTMInputNumbers = new List<int>();


    private string selectedExperiment; // Выбранный эксперимент
    private List<string> availableExperiments = new List<string>(); // Список экспериментов

    private Dictionary<string, string> experimentValues = new Dictionary<string, string>();

    private Dictionary<int, ExperimentData> experimentDataCache = new();




    protected override async Task OnInitializedAsync()
    {
        await LoadDataAsync();
        // Загрузка данных эксперимента
        await LoadExperimentValuesAsync();
    }


    private async Task LoadDataAsync()
    {
        try
        {
            // Загружаем метки "Входные данные" и экспериментов из базы данных
            tm = await _context.tm
                .AsNoTracking()
                .Where(t => t.experiment_label == "Входные данные"
                          || t.experiment_label.StartsWith("Эксперимент"))
                .ToListAsync();

            // Выводим данные
            Console.WriteLine($"Загружено {tm.Count} записей.");

            // Если данных нет, выводим ошибку
            if (tm.Count == 0)
            {
                Console.WriteLine("Нет данных в базе для фильтрации.");
            }

            // Фильтруем входные данные для отображения по умолчанию
            filteredTm = tm.Where(t => t.experiment_label == "Входные данные").ToList();

            // Собираем список уникальных экспериментов
            availableExperiments = tm
                .Where(t => t.experiment_label.StartsWith("Эксперимент"))
                .Select(t => t.experiment_label)
                .Distinct()
                .OrderBy(label => label)
                .ToList();

            // Показываем выпадающий список только если есть эксперименты
            IsDropdownVisible = availableExperiments.Any();
            StateHasChanged(); // Обновление UI
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error fetching data: {ex.Message}");
        }
    }



    private async Task SortDataAsync(string column)
    {
        if (currentSortColumn == column)
        {
            isAscending = !isAscending;
        }
        else
        {
            currentSortColumn = column;
            isAscending = true;
        }

        filteredTm = column switch
        {
            nameof(NedostovernayaTM.ID) => isAscending ? filteredTm.OrderBy(t => t.ID).ToList() : filteredTm.OrderByDescending(t => t.ID).ToList(),
            nameof(NedostovernayaTM.IndexTm) => isAscending ? filteredTm.OrderBy(t => t.IndexTm).ToList() : filteredTm.OrderByDescending(t => t.IndexTm).ToList(),
            nameof(NedostovernayaTM.Id1) => isAscending ? filteredTm.OrderBy(t => t.Id1).ToList() : filteredTm.OrderByDescending(t => t.Id1).ToList(),
            nameof(NedostovernayaTM.CorrTm) => isAscending ? filteredTm.OrderBy(t => t.CorrTm).ToList() : filteredTm.OrderByDescending(t => t.CorrTm).ToList(),
            nameof(NedostovernayaTM.Status) => isAscending ? filteredTm.OrderBy(t => t.Status).ToList() : filteredTm.OrderByDescending(t => t.Status).ToList(),
            nameof(NedostovernayaTM.MaxLagranj) => isAscending ? filteredTm.OrderBy(t => t.MaxLagranj).ToList() : filteredTm.OrderByDescending(t => t.MaxLagranj).ToList(),
            nameof(NedostovernayaTM.AvgLagranj) => isAscending ? filteredTm.OrderBy(t => t.AvgLagranj).ToList() : filteredTm.OrderByDescending(t => t.AvgLagranj).ToList(),
            _ => filteredTm
        };
        // Обновляем интерфейс
        await InvokeAsync(StateHasChanged);
    }

    private void SearchData()
    {
        if (string.IsNullOrEmpty(searchTerm))
        {
            filteredTm = tm;
        }
        else
        {
            filteredTm = tm.Where(t => t.IndexTm.ToString().Contains(searchTerm, StringComparison.OrdinalIgnoreCase)).ToList();
        }
        SortDataAsync(currentSortColumn);
    }

    private void ToggleSearch()
    {
        showSearch = !showSearch;
        if (!showSearch)
        {
            searchTerm = string.Empty;
            SearchData();
        }
    }

    private void ResetSearch()
    {
        searchTerm = string.Empty;
        filteredTm = tm;
        SortDataAsync(currentSortColumn);
    }

    private void ShowChartInput()
    {
        showChartInput = true;
        showChart = false; // Скрыть график при показе ввода для нового графика
    }

    private void HideChart()
    {
        showChart = false;
        chartDataAvailable = false;
    }

    private string GetYAxisLabel(string privyazka)
    {
        return privyazka switch
        {
            "U" => "U, кВ",
            "Pнач" or "Pкон" or "P_ген-р" or "Pген" or "Pнаг" => "P, МВт",
            "Qнач" or "Qкон" or "Q_ген-р" or "Qген" or "Qнаг" => "Q, МВар",
            _ => "Значения"
        };
    }

    private async Task FilterByExperimentAsync(ChangeEventArgs e)
    {
        selectedExperiment = e.Value?.ToString();

        // Выводим количество данных в tm перед фильтрацией
        Console.WriteLine($"Количество данных в tm: {tm.Count()}");

        if (!string.IsNullOrEmpty(selectedExperiment) && selectedExperiment != "Входные данные")
        {
            // Получаем входные и экспериментальные данные
            var inputData = tm.Where(t => t.experiment_label == "Входные данные").ToList();
            var experimentData = tm.Where(t => t.experiment_label == selectedExperiment).ToDictionary(t => t.IndexTm);

            // Выводим количество записей для входных данных и экспериментальных данных
            Console.WriteLine($"Входных данных: {inputData.Count}, Экспериментальных данных: {experimentData.Count}");

            // Объединяем входные данные и экспериментальные
            filteredTm = inputData
    .Where(input => experimentData.ContainsKey(input.IndexTm))
    .Select(input =>
    {
        var experiment = experimentData[input.IndexTm];

        // Создаем новый объект для таблицы `tm` вместо изменения существующего
        return new NedostovernayaTM
            {
                ID = input.ID, // Сохраняем оригинальный ID, если он важен
                IndexTm = input.IndexTm,
                experiment_label = input.experiment_label,
                CorrTm = experiment.CorrTm,
                Status = experiment.Status,
                MaxLagranj = experiment.MaxLagranj,
                AvgLagranj = experiment.AvgLagranj,
                // Добавляем другие свойства, если они есть
            };
    }).ToList();

            // Выводим отфильтрованные данные
            Console.WriteLine($"Отфильтрованных данных: {filteredTm.Count}");
        }
        else
        {
            // Отображаем только входные данные
            filteredTm = tm.Where(t => t.experiment_label == "Входные данные").ToList();
        }
        await InvokeAsync(StateHasChanged);
    }

    public async Task<string> GetExperimentValueAsync(double indexTm, int id1, string experimentLabel, string fieldName)
    {
        var data = await _context.tm
             .Where(t => t.IndexTm == indexTm && t.Id1 == id1)
             .OrderBy(t => t.experiment_label == "Входные данные" ? 0 : 1)
             .FirstOrDefaultAsync();

        return data != null ? fieldName switch
        {
            "CorrTm" => data.CorrTm.ToString("F4"),
            "MaxLagranj" => data.MaxLagranj.ToString("F4"),
            "AvgLagranj" => data.AvgLagranj.ToString("F4"),
            "Status" => data.Status.ToString(),
            _ => "-"
        } : "-";
    }


    private async Task GenerateChart()
    {
        if (double.TryParse(tmIndexInput, out double tmIndex))
        {
            // Шаг 1: Извлекаем данные по IndexTM
            IQueryable<TMValues> query = _context.TMValues.Where(tv => tv.IndexTM == tmIndex);

            // Извлекаем данные без фильтрации по дате
            var tmValuesList = await query.ToListAsync();

            Console.WriteLine($"Всего записей: {tmValuesList.Count}");

            // Шаг 2: Фильтрация по временному интервалу
            if (startDate.HasValue && endDate.HasValue)
            {
                chartData = tmValuesList
                    .Where(tv =>
                    {
                        // Разделяем строку по символу "_", чтобы получить часы, минуты и секунды
                        var timeParts = tv.NumberOfSrez.Split('_');
                        if (timeParts.Length == 3 &&
                            int.TryParse(timeParts[0], out int hours) &&
                            int.TryParse(timeParts[1], out int minutes) &&
                            int.TryParse(timeParts[2], out int seconds))
                        {
                            // Преобразуем в TimeSpan для сравнения
                            var parsedTime = new TimeSpan(hours, minutes, seconds);
                            var startTime = startDate.Value.TimeOfDay;
                            var endTime = endDate.Value.TimeOfDay;

                            Console.WriteLine($"Parsed TimeSpan: {parsedTime}, StartTime: {startTime}, EndTime: {endTime}");

                            // Сравнение времени без учета даты
                            return parsedTime >= startTime && parsedTime <= endTime;
                        }
                        else
                        {
                            Console.WriteLine($"Ошибка преобразования времени: {tv.NumberOfSrez}");
                            return false;
                        }
                    })
                    .ToList();
            }
            else
            {
                chartData = tmValuesList;
            }

            // Шаг 3: Применение прореживания (если задано)
            if (pruningInterval > 0)
            {
                // Сортируем данные перед прореживанием, чтобы сохранить порядок срезов
                chartData = chartData
                    .OrderBy(tv => tv.NumberOfSrez)
                    .ThenBy(tv => tv.OrderIndex)  // Убедимся, что данные сортируются по порядку
                    .Where((tv, index) => index % pruningInterval == 0)  // Применяем прореживание
                    .ToList();
            }
            else
            {
                // Просто сортируем данные, если интервал прореживания не задан
                chartData = chartData
                    .OrderBy(tv => tv.NumberOfSrez)
                    .ThenBy(tv => tv.OrderIndex)
                    .ToList();
            }

            // Проверяем наличие данных
            if (!chartData.Any())
            {
                Console.WriteLine($"Нет данных для IndexTM: {tmIndex}");
                chartDataAvailable = false;
                return;
            }

            // // Шаг 4: Извлечение дополнительных данных (если необходимо)
            var DataInTm = await _context.tm
                .Where(tm => tm.IndexTm == tmIndex)
                .ToListAsync();

            // Устанавливаем флаг доступности данных для графика
            chartDataAvailable = true;
            showChart = true;

            // Формируем заголовок и метку оси Y для графика
            string chartTitle = $"Индекс ТМ: {chartData[0].IndexTM}, Наименование: {chartData[0].NameTM}";
            string yAxisLabel = GetYAxisLabel(chartData[0].Privyazka);

            // Убедитесь, что элемент доступен перед вызовом JS
            await Task.Delay(100);
            StateHasChanged();

            // Шаг 5: Вызов JavaScript для генерации графика
            try
            {
                await JS.InvokeVoidAsync("generateChart", chartElement, chartData, DataInTm, chartTitle, yAxisLabel);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Ошибка вызова JavaScript: {ex.Message}");
            }
        }
        else
        {
            chartDataAvailable = false;
            Console.WriteLine("Некорректный ввод номера ТМ.");
        }
    }

    private string GetCellClass(string status, string dataType)
    {
        Console.WriteLine($"Status: {status}, DataType: {dataType}");
        if (dataType == "Входные данные")
        {
            return status switch
            {
                "Достоверная" => "input-status-dostovernaya",
                "Сомнительная" => "input-status-somnitelnaya",
                "Недостоверная" => "input-status-nedostovernaya",
                _ => string.Empty
            };
        }
        else if (dataType == "Эксперимент")
        {
            return status switch
            {
                "Достоверная" => "experiment-status-dostovernaya",
                "Сомнительная" => "experiment-status-somnitelnaya",
                "Недостоверная" => "experiment-status-nedostovernaya",
                _ => string.Empty
            };
        }
        return string.Empty;
    }
    private async Task ApplyTimeIntervalFilter(bool isThinning = false)
    {
        if (startDate.HasValue && endDate.HasValue)
        {
            await FilterByTimeInterval(isThinning);
        }
        else
        {
            await RetrieveAllData(isThinning);
        }
    }

    private async Task FilterByTimeInterval(bool isThinning)
    {
        var filePaths = await sliceService.GetFilePathsInRangeAsync(startDate.Value, endDate.Value);

        if (!filePaths.Any())
        {
            Console.WriteLine("Нет найденных путей файлов для заданного временного интервала.");
            return;
        }

        var sliceIdsInRange = await _context.slices
            .Where(s => filePaths.Contains(s.SlicePath))
            .Select(s => s.SliceID)
            .ToListAsync();

        if (!sliceIdsInRange.Any())
        {
            Console.WriteLine("Нет идентификаторов срезов для заданных путей файлов.");
            return;
        }

        filteredTMValues = await _context.TMValues
            .Where(t => sliceIdsInRange.Contains(t.SliceID))
            .ToListAsync();

        if (!filteredTMValues.Any())
        {
            Console.WriteLine("filteredTMValues пуст после фильтрации.");
            return;
        }

        UpdateChartSourceData(filteredTMValues);

        if (isThinning)
        {
            ApplyThinning();
        }
    }

    private async Task RetrieveAllData(bool isThinning)
    {
        filteredTMValues = await _context.TMValues.ToListAsync();
        UpdateChartSourceData(filteredTMValues);

        if (!filteredTMValues.Any())
        {
            Console.WriteLine("Нет данных в TMValues.");
            return;
        }

        if (isThinning)
        {
            ApplyThinning();
        }
    }

    private void UpdateChartSourceData(List<TMValues> data)
    {
        chartSourceData = data.ToList();
        Console.WriteLine($"Найдено {data.Count} значений после фильтрации по времени.");
    }

    private void ApplyThinning()
    {
        if (pruningInterval <= 0)
        {
            Console.WriteLine("thinningInterval должен быть больше 0.");
            return;
        }

        filteredTMValues = filteredTMValues
            .Where((t, index) => index % pruningInterval == 0)
            .ToList();

        UpdateChartSourceData(filteredTMValues);
        Console.WriteLine($"Прореживание данных: осталось {filteredTMValues.Count} значений.");
    }

    private void ToggleSelectedActions()
    {
        showModal = !showModal;
    }

    private void CloseModal()
    {
        showModal = false;
    }

    void AddToSelectedActions(VerificationAction action)
    {
        // Проверяем, что комбинация TelemetryId и Id1 уникальн
        if (!selectedActions.Any(a => a.TelemetryId == action.TelemetryId && a.Id1 == action.Id1))
        {
            selectedActions.Add(action);
        }
    }

    private async Task ConfirmActions(List<TMValues> tmValues)
    {
        // Создаем новый список для действий, включая каждую запись из selectedActions
        List<VerificationAction> actionsToExecute = selectedActions
            .Select(action => new VerificationAction
                {
                    ActionName = action.ActionName,
                    TelemetryId = action.TelemetryId,
                    Id1 = action.Id1,
                    StartDate = action.StartDate,
                    EndDate = action.EndDate
                })
            .ToList();

        // Выполнение действий через ActionService
        await ActionService.ExecuteAction(
            actionsToExecute, 
            tmValues,
            UpdateProgress,
            SetStatusBarVisible
        );

        // Очищаем выбранные действия и закрываем модальное окно
        //selectedActions.Clear();
        showModal = false;
        Console.WriteLine("Выбранные действия успешно выполнены.");
        isActionConfirmed = true;
        ToggleMonitoringOptions();
    }


    private async Task SetFilteredTMValues(List<TMValues> values)
    {
        // Сохраняем исходное состояние, если оно ещё не сохранено
        if (originalTMValues == null)
        {
            originalTMValues = new List<TMValues>(filteredTMValues);
        }

        // Обновляем основной список
        filteredTMValues = values;

        // Разделяем данные в зависимости от контекста (ручной ввод или выбор)
        if (isManualInput)
        {
            manualTMValues = new List<TMValues>(values);
        }
        else
        {
            selectedTMValues = new List<TMValues>(values);
        }

        await InvokeAsync(StateHasChanged); // Обновление интерфейса
    }



    private void SelectAction(NedostovernayaTM telemetry, string action)
    {
        if (!string.IsNullOrEmpty(action) && startDate.HasValue && endDate.HasValue)
        {
            // Проверяем, существует ли уже действие с таким же TelemetryId и Id1
            var existingAction = selectedActions.FirstOrDefault(a => a.TelemetryId == (int)telemetry.IndexTm && a.Id1 == (int)telemetry.Id1);

            if (existingAction != default)
            {
                // Удаляем существующую запись, если она совпадает по TelemetryId и Id1
                selectedActions.Remove(existingAction);
            }

            // Добавляем новое действие для текущего TelemetryId и Id1
            selectedActions.Add(new VerificationAction
                {
                    TelemetryId = (int)telemetry.IndexTm,
                    Id1 = (int)telemetry.Id1,
                    ActionName = action,
                    StartDate = startDate.Value,
                    EndDate = endDate.Value
                });
        }
        else if (string.IsNullOrEmpty(action))
        {
            // Удаляем все действия, если пользователь выбрал пустое значение, по сочетанию TelemetryId и Id1
            selectedActions.RemoveAll(a => a.TelemetryId == (int)telemetry.IndexTm && a.Id1 == (int)telemetry.Id1);
        }
    }

    private void ShowTrackingOptions()
    {
        // Здесь можно открыть выпадающий список с вариантами отслеживания
        // Например, можно использовать булеву переменную для контроля видимости списка
        isTrackingOptionsVisible = true;
    }

}

@if (showTimeIntervalInput)
{
    <div class="mb-3">
        <label>Начало временного промежутка:</label>
        <input type="datetime-local" @bind="startDate" class="form-control" />
        <label>Конец временного промежутка:</label>
        <input type="datetime-local" @bind="endDate" class="form-control" />

        @if (showThinningInput)
        {
            <div class="mb-3">
                <label>Интервал прореживания:</label>
                <input type="number" @bind="pruningInterval" min="1" class="form-control" />
            </div>
        }

        <div class="mt-2">
            <button @onclick="() => ApplyTimeIntervalFilter(false)" class="btn btn-primary me-2">Применить фильтр</button>
            <button @onclick="() => ApplyTimeIntervalFilter(true)" class="btn btn-secondary">Прореживать данные</button>
        </div>
    </div>
}

<h2>Выявленные недостоверности ТМ</h2>

<button @onclick="() => showTimeIntervalInput = !showTimeIntervalInput" class="btn btn-primary mt-2">
    @(showTimeIntervalInput ? "Скрыть выбор времени" : "Показать выбор времени")
</button>

<button @onclick="() => showThinningInput = !showThinningInput" class="btn btn-primary mt-2">
    @(showThinningInput ? "Скрыть интервал прореживания" : "Задать интервал прореживания")
</button>


<!-- Кнопка для запуска расчёта корреляции для всех ТМ -->
<button @onclick="OnCalculateCorrelation" class="btn btn-primary mt-2" disabled="@isCalculating">
    Рассчитать корреляцию
</button>


<!-- Кнопка для остановки расчёта -->
<button @onclick="OnStopCalculation" class="btn btn-danger mt-2" disabled="@(isCalculating == false)">
    Остановить расчет
</button>

@if (isStatusBarVisible)
{
    <!-- Прогресс-бар -->
    <div class="progress mt-4">
        <div class="progress-bar" role="progressbar" style="width: @currentProgress%" aria-valuenow="@currentProgress" aria-valuemin="0" aria-valuemax="100">
            @currentProgress%
        </div>
    </div>
}

@code {
    private bool isCalculating = false;
    private bool isStatusBarVisible = false;
    private int currentProgress = 0;
    private CancellationTokenSource cancellationTokenSource;

    // Метод расчета корреляции для всех ТМ
    private async Task OnCalculateCorrelation()
    {
        // Проверяем, запущен ли расчет
        if (isCalculating) return;

        // Загружаем все данные ТМ, если `filteredTMValues` не задан
        var tmValues = filteredTMValues ?? await MonitoringService.MonitorAllTMAsync(filteredTMValues);
        await ExecuteCorrelationCalculation(tmValues);
    }

    // Метод расчета корреляции для отфильтрованных ТМ (используется в ApplyChangesAndCalculateCorrelation)
    private async Task OnCalculateCorrelation(List<TMValues> tmValues)
    {
        if (isCalculating) return;
        await ExecuteCorrelationCalculation(tmValues);
    }

    // Общий метод для расчета корреляции
    private async Task ExecuteCorrelationCalculation(List<TMValues> tmValues)
    {
        isCalculating = true;
        isStatusBarVisible = true;
        cancellationTokenSource = new CancellationTokenSource();

        await InvokeAsync(StateHasChanged);

        try
        {
            // Запускаем расчет корреляции с учетом фильтрации данных
            await corr.CalculationCorrelation(
                tmValues,                // Передаем значения ТМ для расчета
                UpdateProgress,          // Метод для обновления прогресса
                SetStatusBarVisible,     // Метод для управления видимостью статусбара
                startDate,               // Начальная дата
                endDate,                 // Конечная дата
                false,
                1,
                cancellationTokenSource.Token
            );
        }
        catch (OperationCanceledException)
        {
            Console.WriteLine("Расчет был остановлен.");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Ошибка при расчете корреляции: {ex.Message}");
        }
        finally
        {
            isCalculating = false;
            isStatusBarVisible = false;
            cancellationTokenSource.Dispose();
            await InvokeAsync(StateHasChanged);
        }
    }

    // Метод для обновления прогресса
    private void UpdateProgress(int progress)
    {
        InvokeAsync(() =>
        {
            currentProgress = progress;
            StateHasChanged();
        });
    }

    // Метод для управления видимостью статусбара
    private void SetStatusBarVisible(bool isVisible)
    {
        InvokeAsync(() =>
        {
            isStatusBarVisible = isVisible;
            StateHasChanged();
        });
    }

    private async Task OnStopCalculation()
    {
        if (cancellationTokenSource != null)
        {
            // Останавливаем текущий расчет
            cancellationTokenSource.Cancel();
            cancellationTokenSource.Dispose();
            cancellationTokenSource = null;
        }

        // Обновляем состояние интерфейса
        isCalculating = false;
        isStatusBarVisible = false;
        await InvokeAsync(StateHasChanged);
    }


    // Метод для применения изменений и расчета корреляции для отфильтрованных ТМ
    private async Task ApplyChangesAndCalculateCorrelation()
    {
        try
        {
            // Подтверждаем действия для текущего списка
            ConfirmActions(filteredTMValues);

            // Получаем последнюю метку эксперимента
            var latestExperimentLabel = await MonitoringService.GetNextExperimentLabelAsync();

            // Инициализируем новый класс
            var experimentCorrData = new ExperimentCorrData(_context);

            // Объединяем наборы из выпадающего списка и вручную введённые номера ТМ
            var selectedTMValues = filteredTMValues;

            if (manualTMInputNumbers != null && manualTMInputNumbers.Any())
            {
                // Преобразуем номера из ручного ввода в список TMValues
                var manualTMValues = await MonitoringService.ManualMonitorSetupAsync(manualTMInputNumbers, selectedTMValues.ToList());

                // Объединяем списки и удаляем дубликаты
                selectedTMValues = selectedTMValues
                    .Union(manualTMValues)
                    .GroupBy(tm => new { tm.IndexTM, tm.Id1, tm.Privyazka })
                    .Select(group => group.First())
                    .ToList();
            }

        }
        finally
        {
            // Восстанавливаем исходное состояние из originalTMValues
            if (originalTMValues != null)
            {
                filteredTMValues = originalTMValues;
                originalTMValues = null; // Сбрасываем оригинал после восстановления
            }

            // Обновляем интерфейс
            await InvokeAsync(StateHasChanged);
        }
    }
}


<button @onclick="ShowChartInput" class="btn btn-primary mt-2">Показать график корреляции</button>

@if (showSearch)
{
    <div class="mb-3">
        <input @bind="searchTerm" placeholder="Поиск по Index TM" class="form-control" />
        <button @onclick="SearchData" class="btn btn-primary mt-2">Искать</button>
        <button @onclick="ResetSearch" class="btn btn-secondary mt-2 ml-2">Сбросить</button>
    </div>
}

@if (showChartInput)
{
    <div class="mb-3">
        <input @bind="tmIndexInput" placeholder="Введите номер ТМ" class="form-control" />
        <button @onclick="GenerateChart" class="btn btn-primary mt-2">Построить график</button>
    </div>
}

@if (chartDataAvailable && showChart)
{
    <div class="mt-4">
        <button @onclick="HideChart" class="btn btn-secondary mb-2">Закрыть график</button>
        <canvas id="chart" width="400" height="200" @ref="chartElement"></canvas>
    </div>
}

<!-- Кнопка для показа выбранных действий -->
@if (selectedActions.Any())
{
    <button class="btn btn-primary" @onclick="ToggleSelectedActions">Показать выбранные действия</button>
}

@if (showModal)
{
    <div class="alert alert-info mt-3">
        <h5>Выбранные действия</h5>
        <h6>Выбранный интервал: от @startDate.Value.ToString("g") до @endDate.Value.ToString("g")</h6>

        <!-- Таблица с выбранными действиями -->
        <table class="table table-bordered mt-3">
            <thead>
                <tr>
                    <th>Индекс ТМ</th>
                    <th>Узел</th>
                    <th>Действие</th>
                </tr>
            </thead>
            <tbody>
                @foreach (var action in selectedActions)
                {
                    <tr>
                        <td>@action.TelemetryId</td>
                        <td>@action.Id1</td>
                        <td>@action.ActionName</td>
                    </tr>
                }
            </tbody>
        </table>

        <!-- Кнопка для выбора отслеживаемых телеизмерений и расчета корреляции -->
        <div class="mt-3">
            <!-- Кнопка для выбора отслеживаемых телеизмерений -->
            <button class="btn btn-primary dropdown-toggle" type="button" @onclick="ToggleMonitoringOptions" aria-expanded="false">
                Выбрать отслеживаемые телеизмерения
            </button>
            @if (showOptions)
            {
                <ul class="dropdown-menu show">
                    <li>
                        <a class="dropdown-item" 
                        @onclick="async () => 
                        {
                            var newValues = await MonitoringService.MonitorAllTMAsync(filteredTMValues.ToList());
                            await SetFilteredTMValues(newValues);
                            ToggleMonitoringOptions();
                        }">
                        Отслеживать изменения для всех ТМ
                    </a>
                    </li>
                    <li>
                        <a class="dropdown-item" 
                        @onclick="async () => 
                        {
                            var newValues = await MonitoringService.MonitorUnreliableAndQuestionableTMAsync(filteredTMValues.ToList());
                            await SetFilteredTMValues(newValues);
                            ToggleMonitoringOptions();
                        }">
                        Отслеживать изменения для недостоверных и сомнительных ТМ
                    </a>
                    </li>
                    <li>
                        <a class="dropdown-item"
                        @onclick="async () =>
                        {
                            var newValues = await MonitoringService.MonitorUnreliableTMAsync(filteredTMValues.ToList());
                            await SetFilteredTMValues(newValues);
                            ToggleMonitoringOptions();
                        }">
                        Отслеживать изменения для недостоверных ТМ
                    </a>
                    </li>
                    <li>
                        <a class="dropdown-item"
                           @onclick="async () =>
                           {
                                var telemetryKeys = selectedActions
                                    .Select(a => (a.TelemetryId, a.Id1))
                                    .ToList();

                                var newValues = await MonitoringService.MonitorVerifiedTMAsync(telemetryKeys, filteredTMValues.ToList());

                                // Передача обновлённого списка
                                await SetFilteredTMValues(newValues);

                               ToggleMonitoringOptions();
                           }">
                            Отслеживать изменения для ТМ, которые были достоверизованы
                        </a>
                    </li>
                </ul>
            }
            <button class="btn btn-secondary mt-2" @onclick="OpenManualMonitorModal">Задать список отслеживаемых ТМ вручную</button>

        </div>
        @if (showManualMonitorModal)
        {
            <!-- Модальное окно для ручного ввода списка отслеживаемых ТМ -->
            <div class="modal d-block" tabindex="-1">
                <div class="modal-dialog">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title">Введите номера ТМ для отслеживания</h5>
                            <button type="button" class="btn-close" @onclick="CloseManualMonitorModal"></button>
                        </div>
                        <div class="modal-body">
                            <!-- Поле ввода номеров ТМ -->
                            <input type="text" class="form-control" @bind="manualTMInput" placeholder="Введите номера ТМ через запятую">
                            @if (!string.IsNullOrEmpty(errorMessage))
                            {
                                <div class="text-danger mt-2">@errorMessage</div>
                            }
                        </div>
                        <div class="modal-footer">
                            <!-- Кнопка отмены -->
                            <button type="button" class="btn btn-secondary" @onclick="CloseManualMonitorModal">Отмена</button>
                            <!-- Кнопка подтверждения ручного ввода -->
                            <button type="button" class="btn btn-primary" @onclick="ValidateAndSubmitManualTMInput">
                                Подтвердить только введённые вручную ТМ
                            </button>
                            <!-- Кнопка объединения -->
                            @if (selectedTMValues.Any() || !string.IsNullOrEmpty(manualTMInput))
                            {
                                <button class="btn btn-primary" @onclick="async () => await CombineAndSubmitSets()">
                                    Объединить выбранный готовый набор и введённые вручную ТМ
                                </button>
                            }
                        </div>
                    </div>
                </div>
            </div>
        }

        <!-- Объединенная кнопка для применения изменений и расчета корреляции -->
        <div class="mt-3">
            <button class="btn btn-success" @onclick="ApplyChangesAndCalculateCorrelation">
                Применить изменения и рассчитать корреляцию для отслеживаемых ТМ
            </button>
            <button class="btn btn-secondary" @onclick="CloseModal">Закрыть</button>
        </div>
    </div>
}

@code {
    private bool showOptions = false;

    private void ToggleMonitoringOptions()
    {
        isManualInput = false;
        showOptions = !showOptions;
    }

    private void OpenManualMonitorModal()
    {
        showManualMonitorModal = true;
        errorMessage = string.Empty;
    }

    private void CloseManualMonitorModal()
    {
        showManualMonitorModal = false;
        manualTMInput = string.Empty;
        errorMessage = string.Empty;
    }

    private async Task ValidateAndSubmitManualTMInput()
    {
        isManualInput = true; // Указываем, что данные вводятся вручную

        try
        {
            // Вызываем валидацию через ValidationService
            var validationResult = await ValidationService.ValidateTMInputAsync(manualTMInput);

            if (!validationResult.IsValid)
            {
                errorMessage = string.Join("; ", validationResult.Errors);
                return;
            }

            // Преобразуем список строк в список целых чисел
            var tmNumbers = validationResult.TMNumbers.Select(int.Parse).ToList();

            // Сбрасываем filteredTMValues к исходному состоянию
            if (originalTMValues != null)
            {
                filteredTMValues = new List<TMValues>(originalTMValues);
            }

            // Если валидация прошла успешно, выполняем логику для отслеживания
            var filteredTMValuesAfterValidation =
                await MonitoringService.ManualMonitorSetupAsync(tmNumbers, filteredTMValues.ToList());

            // Если найденных значений нет, выводим сообщение
            if (filteredTMValuesAfterValidation == null || !filteredTMValuesAfterValidation.Any())
            {
                errorMessage = "Не найдено подходящих значений.";
                return;
            }

            // Передаём результат в SetFilteredTMValues для обновления интерфейса
            await SetFilteredTMValues(filteredTMValuesAfterValidation);

            // Закрываем модальное окно
            CloseManualMonitorModal();
        }
        catch (Exception ex)
        {
            // Логируем ошибку и выводим сообщение
            Console.WriteLine($"Ошибка при ручной настройке мониторинга: {ex.Message}");
            errorMessage = "Произошла ошибка при обработке данных. Попробуйте снова.";
        }
    }

    private async Task CombineAndSubmitSets()
    {
        // Обрабатываем ввод вручную перед объединением
        await ValidateAndSubmitManualTMInput();

        // Проверяем, если данные готовы
        if (selectedTMValues.Any() && manualTMValues.Any())
        {
            // Объединяем наборы
            var combinedSet = await MonitoringService.CombineMonitoringSetsAsync(selectedTMValues, manualTMValues);

            // Обновляем интерфейс
            await SetFilteredTMValues(combinedSet);

            // Закрываем модальное окно
            CloseManualMonitorModal();
            await InvokeAsync(StateHasChanged);
        }
    }

    private string GetSelectedAction(int telemetryId, int id1) =>
    selectedActions.FirstOrDefault(a => a.TelemetryId == telemetryId && a.Id1 == id1)?.ActionName ?? string.Empty;

    private async Task LoadExperimentValuesAsync()
    {
        foreach (var telemetry in filteredTm)
        {
            foreach (var field in new[] { "CorrTm", "Status", "MaxLagranj", "AvgLagranj" })
            {
                var value = await GetExperimentValueAsync(telemetry.IndexTm, telemetry.Id1, selectedExperiment, field);
                experimentValues[$"{telemetry.IndexTm}_{telemetry.Id1}_{field}"] = value;
            }
        }
    }

    private string GetExperimentValue(double indexTm, int id1, string fieldName) =>
     experimentValues.GetValueOrDefault($"{indexTm}_{id1}_{fieldName}", "Значение не найдено");

}

@if (IsDropdownVisible)
{
    <div class="form-group">
        <label for="experimentSelect">Выберите эксперимент:</label>
        <select id="experimentSelect" class="form-select" @onchange="FilterByExperimentAsync">
            <option value="" selected>Входные данные</option>
            @foreach (var experiment in availableExperiments)
            {
                <option value="@experiment">@experiment</option>
            }
        </select>
    </div>
}


@if (filteredTm == null || !filteredTm.Any())
{
    <p>Нет данных для отображения.</p>
}
else
{
    <table class="table table-bordered">
        <thead>
            <!-- Первый уровень заголовков -->
            <tr>
                <th colspan="8" class="text-center">Входные данные</th>
                @if (!string.IsNullOrEmpty(selectedExperiment) && selectedExperiment != "Входные данные")
                {
                    <th colspan="4" class="text-center">Значения экспериментов</th>
                }
            </tr>
            <!-- Второй уровень заголовков -->
            <tr>
                <th @onclick="() => SortDataAsync(nameof(NedostovernayaTM.ID))">
                    Идентификатор @(currentSortColumn == nameof(NedostovernayaTM.ID) ? (isAscending ? "▲" : "▼") : "")
                </th>
                <th>
                    <span @onclick="() => SortDataAsync(nameof(NedostovernayaTM.IndexTm))" style="cursor:pointer;">
                        Индекс ТМ @(currentSortColumn == nameof(NedostovernayaTM.IndexTm) ? (isAscending ? "▲" : "▼") : "")
                    </span>
                    <button @onclick="ToggleSearch" class="btn btn-link" style="padding:0; margin-left:5px;">
                        🔍
                    </button>
                </th>
                <th @onclick="() => SortDataAsync(nameof(NedostovernayaTM.CorrTm))">
                    Узел @(currentSortColumn == nameof(NedostovernayaTM.Id1) ? (isAscending ? "▲" : "▼") : "")
                </th>
                <th @onclick="() => SortDataAsync(nameof(NedostovernayaTM.CorrTm))">
                    Коэффициент корреляции @(currentSortColumn == nameof(NedostovernayaTM.CorrTm) ? (isAscending ? "▲" : "▼") : "")
                </th>
                <th @onclick="() => SortDataAsync(nameof(NedostovernayaTM.Status))">
                    Статус @(currentSortColumn == nameof(NedostovernayaTM.Status) ? (isAscending ? "▲" : "▼") : "")
                </th>
                <th @onclick="() => SortDataAsync(nameof(NedostovernayaTM.MaxLagranj))">
                    Максимальное значение лагранжиана @(currentSortColumn == nameof(NedostovernayaTM.MaxLagranj) ? (isAscending ? "▲" : "▼") : "")
                </th>
                <th @onclick="() => SortDataAsync(nameof(NedostovernayaTM.AvgLagranj))">
                    Среднее значение лагранжиана @(currentSortColumn == nameof(NedostovernayaTM.AvgLagranj) ? (isAscending ? "▲" : "▼") : "")
                </th>
                <th @onclick="() => SortDataAsync(nameof(NedostovernayaTM.recomendedActions))">
                    Действия по достоверизации @(currentSortColumn == nameof(NedostovernayaTM.recomendedActions) ? (isAscending ? "▲" : "▼") : "")
                </th>
                @if (!string.IsNullOrEmpty(selectedExperiment) && selectedExperiment != "Входные данные")
                {
                    <th>Коэффициент корреляции</th>
                    <th>Статус</th>
                    <th>Максимальное значение лагранжиана</th>
                    <th>Среднее значение лагранжиана</th>
                }
            </tr>
        </thead>
        <tbody>
            @foreach (var telemetry in filteredTm)
            {
                <tr>
                    <!-- Если выбран "Входные данные" -->
                    @if (string.IsNullOrEmpty(selectedExperiment) || selectedExperiment == "Входные данные")
                    {
                        <!-- Входные данные -->
                        <td class="@GetCellClass(telemetry.Status, "Входные данные")">@telemetry.ID</td>
                        <td class="@GetCellClass(telemetry.Status, "Входные данные")">@telemetry.IndexTm</td>
                        <td class="@GetCellClass(telemetry.Status, "Входные данные")">@telemetry.Id1</td>
                        <td class="@GetCellClass(telemetry.Status, "Входные данные")">@Math.Round(telemetry.CorrTm, 4)</td>
                        <td class="@GetCellClass(telemetry.Status, "Входные данные")">@telemetry.Status</td>
                        <td class="@GetCellClass(telemetry.Status, "Входные данные")">@Math.Round(telemetry.MaxLagranj, 4)</td>
                        <td class="@GetCellClass(telemetry.Status, "Входные данные")">@Math.Round(telemetry.AvgLagranj, 4)</td>
                    }
                    else
                    {
                        <!-- Данные для выбранного эксперимента -->
                        <td>@GetExperimentValueAsync(telemetry.IndexTm, telemetry.Id1, "Входные данные", "ID")</td>
                        <td>@GetExperimentValueAsync(telemetry.IndexTm, telemetry.Id1, "Входные данные", "IndexTm")</td>
                        <td>@GetExperimentValueAsync(telemetry.IndexTm, telemetry.Id1, "Входные данные", "Id1")</td>
                        <td>@GetExperimentValueAsync(telemetry.IndexTm, telemetry.Id1, "Входные данные", "CorrTm")</td>
                        <td>@GetExperimentValueAsync(telemetry.IndexTm, telemetry.Id1, "Входные данные", "Status")</td>
                        <td>@GetExperimentValueAsync(telemetry.IndexTm, telemetry.Id1, "Входные данные", "MaxLagranj")</td>
                        <td>@GetExperimentValueAsync(telemetry.IndexTm, telemetry.Id1, "Входные данные", "AvgLagranj")</td>
                    }

                    <!-- Выбор действия -->
                    <td class="@GetCellClass(telemetry.Status, "Входные данные")">
                        <select class="form-select"
                                value="@GetSelectedAction((int)telemetry.IndexTm, telemetry.Id1)"
                                @onchange="(e) => SelectAction(telemetry, e.Value.ToString())">
                            <option value="">Выберите действие</option>
                            <option value="Изменить знак ТМ">Изменить знак ТМ</option>
                            <option value="Создать дорасчет">Создать дорасчет</option>
                            <option value="Исключить из ОС">Исключить из ОС</option>
                        </select>
                    </td>
                    <!-- Данные для выбранного эксперимента -->
                    @if (!string.IsNullOrEmpty(selectedExperiment)  && selectedExperiment != "Входные данные")
                    {
                        <td>@GetExperimentValue(telemetry.IndexTm, telemetry.Id1, "CorrTm")</td>
                        <td>@GetExperimentValue(telemetry.IndexTm, telemetry.Id1, "Status")</td>
                        <td>@GetExperimentValue(telemetry.IndexTm, telemetry.Id1, "MaxLagranj")</td>
                        <td>@GetExperimentValue(telemetry.IndexTm, telemetry.Id1, "AvgLagranj")</td>
                    }
                </tr>
            }
        </tbody>
    </table>
}






