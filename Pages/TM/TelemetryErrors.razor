@page "/nedostovernost"
@using перенос_бд_на_Web.Models
@using Microsoft.EntityFrameworkCore
@using перенос_бд_на_Web.Models
@using перенос_бд_на_Web.Data
@using перенос_бд_на_Web.Services
@using System.Text.RegularExpressions;
@inject SliceService sliceService
@inject ActionService ActionService
@inject TelemetryMonitoringService MonitoringService
@inject ValidationService ValidationService
@inject ApplicationContext _context
@inject CorrData corr
@inject IJSRuntime JS

<PageTitle>Поиск некорректной ТМ </PageTitle>

<style>
    .status-dostovernaya {
        background-color: lightgreen;
    }

    .status-somnitelnaya {
        background-color: lightyellow;
    }

    .status-nedostovernaya {
        background-color: lightcoral;
    }
</style>

@code {
    private List<NedostovernayaTM> tm = new List<NedostovernayaTM>();
    private List<NedostovernayaTM> filteredTm = new List<NedostovernayaTM>();
    public List<TMValues> filteredTMValues = new List<TMValues>();
    private List<TMValues> originalTMValues; // Исходный набор данных
    private string currentSortColumn;
    private bool isAscending = true;
    private string searchTerm = string.Empty;
    private bool showSearch = false;
    private bool showChartInput = false;
    private bool showChart = false;
    private string tmIndexInput = string.Empty;
    private List<TMValues> chartData = new List<TMValues>();
    private bool chartDataAvailable = false;
    private ElementReference chartElement;
    private DateTime? startDate;
    private DateTime? endDate;
    private bool showTimeIntervalInput = false;
    private List<NedostovernayaTM> tmData = new List<NedostovernayaTM>();
    private bool showThinningInput = false; // Показывать ли поле для ввода интервала прореживания
    private int pruningInterval = 1; // Интервал прореживания по умолчанию
    private List<TMValues> chartSourceData = new List<TMValues>();
    public bool IsDropdownVisible { get; set; }  // Новое свойство
    private NedostovernayaTM selectedTelemetry; // Хранит выбранный элемент для отображения действий
    private string selectedAction; // Хранит выбранное действие
    private bool showChangeList = false;
    private List<VerificationAction> selectedActions = new();
    private bool showModal = false;
    private bool isActionConfirmed = false;
    private bool isTrackingOptionsVisible;
    private List<TMValues> filteredTMValuesAfterValidation = new List<TMValues>();

    private bool showManualMonitorModal = false;
    private string manualTMInput;
    private string errorMessage;

    private List<TMValues> selectedTMValues = new();
    private List<TMValues> manualTMValues = new();

    private bool isManualInput = false;

    private List<int> manualTMInputNumbers = new List<int>();


    private string selectedExperiment; // Выбранный эксперимент
    private string newSelectedExperiment; // Для определения эксперимента как набора файлов для следующего эксперимента
    private List<string> availableExperiments = new List<string>(); // Список экспериментов

    private string experimentalKit="Входные данные";

    private List<string> availableValues = new List<string>();

    private bool applyFgo { get; set; } = false;

    private List<string> formulas = new(); // Лист для сохранения формул

    private bool isThinningEnabled { get; set; } = false;

    private bool isDropdownVisible = false;

    private string originalDataSet = "Входные данные";

    private List<string> experimentLabels;

    private bool isLoading = true; // Флаг для отображения индикатора загрузки
    private string loadingMessage = ""; // Сообщение о процессе загрузки

    private string UserMessage { get; set; }

    private UserMessageModel CurrentUserMessage { get; set; }

    private bool IsMessageHiding { get; set; } = false;

    private bool isIntervalApplied = false;

    private bool showExperimentForm = false;
    private List<ExperimentViewModel> experimentData;

    private string currentExperimentSortColumn;

    private bool isExperimentSortAscending = true;



    protected override async Task OnInitializedAsync()
    {
        isLoading = true; // Устанавливаем флаг в true перед началом загрузки
        loadingMessage = "Получение данных из БД...";
        await LoadData();
        isLoading = false; // Снимаем флаг после завершения загрузки
        await InvokeAsync(StateHasChanged);
    }


    private async Task LoadData()
    {
        try
        {
            // Загружаем все данные из таблицы
            tm = await _context.correlation_coefficients.AsNoTracking().ToListAsync();

            // Фильтруем данные с меткой "Входные данные" для исходной таблицы
            filteredTm = tm.Where(t => t.experiment_label == "Входные данные").ToList();

            // Собираем список уникальных экспериментов (только метки, начинающиеся с "Эксперимент")
            availableExperiments = tm
                .Where(t => t.experiment_label.StartsWith("Эксперимент"))
                .Select(t => t.experiment_label)
                .Distinct()
                .OrderBy(label => label)
                .ToList();

            // Создаем список доступных значений, включая "Входные данные"
            availableValues = new List<string> { "Входные данные" };
            availableValues.AddRange(availableExperiments);

            // Показываем выпадающий список только если есть эксперименты
            IsDropdownVisible = availableExperiments.Any();

            // Загружаем уникальные значения experiment_label
            experimentLabels = await GetUniqueExperimentLabels();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error fetching data: {ex.Message}");
        }
        // Обновляем интерфейс
        await InvokeAsync(StateHasChanged);
    }

    private void SortData(string column)
    {
        if (currentSortColumn == column)
        {
            isAscending = !isAscending;
        }
        else
        {
            currentSortColumn = column;
            isAscending = true;
        }

        filteredTm = column switch
        {
            nameof(NedostovernayaTM.ID) => isAscending ? filteredTm.OrderBy(t => t.ID).ToList() : filteredTm.OrderByDescending(t => t.ID).ToList(),
            nameof(NedostovernayaTM.IndexTm) => isAscending ? filteredTm.OrderBy(t => t.IndexTm).ToList() : filteredTm.OrderByDescending(t => t.IndexTm).ToList(),
            nameof(NedostovernayaTM.Id1) => isAscending ? filteredTm.OrderBy(t => t.Id1).ToList() : filteredTm.OrderByDescending(t => t.Id1).ToList(),
            nameof(NedostovernayaTM.CorrTm) => isAscending ? filteredTm.OrderBy(t => t.CorrTm).ToList() : filteredTm.OrderByDescending(t => t.CorrTm).ToList(),
            nameof(NedostovernayaTM.Status) => isAscending
            ? filteredTm.OrderBy(t => GetStatusPriority(t.Status)).ToList()
            : filteredTm.OrderByDescending(t => GetStatusPriority(t.Status)).ToList(),
            nameof(NedostovernayaTM.MaxLagranj) => isAscending ? filteredTm.OrderBy(t => t.MaxLagranj).ToList() : filteredTm.OrderByDescending(t => t.MaxLagranj).ToList(),
            nameof(NedostovernayaTM.AvgLagranj) => isAscending ? filteredTm.OrderBy(t => t.AvgLagranj).ToList() : filteredTm.OrderByDescending(t => t.AvgLagranj).ToList(),
            _ => filteredTm
        };
    }

    // Вспомогательный метод для определения приоритета статуса
    private int GetStatusPriority(string status)
    {
        return status switch
        {
            "Недостоверная" => 1,
            "Сомнительная" => 2,
            "Достоверная" => 3,
            _ => 4 // Если есть неучтённые значения
        };
    }


    private async Task SearchData()
    {
        // Проверяем и заменяем значение selectedExperiment, если оно пустое или null
        if (string.IsNullOrEmpty(selectedExperiment))
        {
            selectedExperiment = "Входные данные";
        }

        if (string.IsNullOrEmpty(searchTerm))
        {
            // Фильтруем по selectedExperiment
            filteredTm = tm.Where(t => t.experiment_label == selectedExperiment).ToList();
            await NotifyUserAsync("Введите номер ТМ для поиска", "error");
        }
        // Проверка: Вводить можно только целочисленные значения
        if (!int.TryParse(searchTerm, out int searchIndex))
        {
            await NotifyUserAsync("Введенное значение должно быть целым числом.", "error");
            return;
        }

        // Проверяем, есть ли введённое значение в таблице correlation_coefficients
        bool existsInDatabase = _context.correlation_coefficients
            .Any(c => c.IndexTm == searchIndex);

        if (!existsInDatabase)
        {
            await NotifyUserAsync("Введенное значение отсутствует в базе данных.", "error");
            return;
        }
        else
        {
            // Фильтруем по searchTerm и selectedExperiment
            filteredTm = tm
                .Where(t => t.experiment_label == selectedExperiment &&
                            t.IndexTm.ToString().Contains(searchTerm, StringComparison.OrdinalIgnoreCase))
                .ToList();
        }
        SortData(currentSortColumn);
    }

    private void ToggleSearch()
    {
        showSearch = !showSearch;
        if (!showSearch)
        {
            searchTerm = string.Empty;
            SearchData();
        }
    }

    private void ResetSearch()
    {
        searchTerm = string.Empty;
        filteredTm = tm;
        SortData(currentSortColumn);
    }

    private void ShowChartInput()
    {
        showChartInput = true;
        showChart = false; // Скрыть график при показе ввода для нового графика
    }

    private async void HideChart()
    {
        // Скрыть график на странице
        showChart = false;
        chartDataAvailable = false;
        // Уничтожить текущий график через JS
        try
        {
            await JS.InvokeVoidAsync("destroyChart");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Ошибка при уничтожении графика: {ex.Message}");
        }
        // Обновить интерфейс
        StateHasChanged();
    }

    private string GetYAxisLabel(string privyazka)
    {
        return privyazka switch
        {
            "U" => "U, кВ",
            "Pнач" or "Pкон" or "P_ген-р" or "Pген" or "Pнаг" => "P, МВт",
            "Qнач" or "Qкон" or "Q_ген-р" or "Qген" or "Qнаг" => "Q, МВар",
            _ => "Значения"
        };
    }

    private void FilterByExperiment(ChangeEventArgs e)
    {
        selectedExperiment = e.Value?.ToString();

        var options = new DbContextOptionsBuilder<ApplicationContext>()
    .UseNpgsql("Host=localhost;Port=5432;Database=БД_ИТ_диплом;Username=postgres;Password=HgdMoxN2;MaxPoolSize=1000")
    .Options;

        using (var context = new ApplicationContext(options))
        {


            if (!string.IsNullOrEmpty(selectedExperiment) && selectedExperiment != "Входные данные")
            {
                // Загружаем актуальные данные из базы
                var allTm = _context.correlation_coefficients.ToList(); // Получаем актуальные данные

                // Получаем входные данные и экспериментальные данные
                var inputData = allTm.Where(t => t.experiment_label == "Входные данные").ToList();
                var experimentData = allTm.Where(t => t.experiment_label == selectedExperiment).ToList();

                // Выводим количество записей для входных данных и экспериментальных данных
                Console.WriteLine($"Входных данных: {inputData.Count}, Экспериментальных данных: {experimentData.Count}");

                // Объединяем входные данные и экспериментальные
                filteredTm = inputData
                    .Where(input => experimentData.Any(experiment => experiment.IndexTm == input.IndexTm))
                    .Select(input =>
                    {
                        var experiment = experimentData.First(experiment => experiment.IndexTm == input.IndexTm);

                        return new NedostovernayaTM
                            {
                                ID = input.ID, // Сохраняем оригинальный ID, если он важен
                                IndexTm = input.IndexTm,
                                experiment_label = input.experiment_label,
                                CorrTm = experiment.CorrTm,
                                Status = experiment.Status,
                                MaxLagranj = experiment.MaxLagranj,
                                AvgLagranj = experiment.AvgLagranj,
                                // Добавляем другие свойства, если они есть
                            };
                    }).ToList();

                // Выводим отфильтрованные данные
                Console.WriteLine($"Отфильтрованных данных: {filteredTm.Count}");
            }
            else
            {
                // Отображаем только входные данные
                filteredTm = tm.Where(t => t.experiment_label == "Входные данные").ToList();
            }
        }

    }

    public string GetExperimentValue(double indexTm, string experimentLabel, string fieldName)
    {
        // Ищем данные для выбранного эксперимента
        var experimentData = tm
            .FirstOrDefault(t => t.IndexTm == indexTm && t.experiment_label == experimentLabel);

        if (experimentData != null)
        {
            Console.WriteLine($"Данные для эксперимента {experimentLabel} с IndexTm {indexTm} найдены.");

            return fieldName switch
            {
                "CorrTm" => experimentData.CorrTm.ToString("F4"),
                "Status" => experimentData.Status,
                "MaxLagranj" => experimentData.MaxLagranj.ToString("F4"),
                "AvgLagranj" => experimentData.AvgLagranj.ToString("F4"),
                "ID" => experimentData.ID.ToString(), // ID
                "IndexTm" => experimentData.IndexTm.ToString(), // IndexTm
                "Id1" => experimentData.Id1.ToString(), // Id1
                _ => "-" // для других полей возвращаем "-"
            };
        }
        else
        {
            // Если данных для эксперимента нет, проверяем данные для "Входные данные"
            var baselineData = tm
                .FirstOrDefault(t => t.IndexTm == indexTm && t.experiment_label == "Входные данные");

            if (baselineData != null)
            {
                Console.WriteLine($"Данные для входных данных с IndexTm {indexTm} найдены.");

                return fieldName switch
                {
                    "CorrTm" => baselineData.CorrTm.ToString("F4"),
                    "Status" => baselineData.Status,
                    "MaxLagranj" => baselineData.MaxLagranj.ToString("F4"),
                    "AvgLagranj" => baselineData.AvgLagranj.ToString("F4"),
                    "ID" => baselineData.ID.ToString(), // ID
                    "IndexTm" => baselineData.IndexTm.ToString(), // IndexTm
                    "Id1" => baselineData.Id1.ToString(), // Id1
                    _ => "-" // для других полей
                };
            }
        }

        Console.WriteLine($"Не удалось найти данные для IndexTm {indexTm}.");
        return "-"; // Если данных нет
    }


    private async Task GenerateChart()
    {
        chartDataAvailable = true;
        showChart = true;
        if (!double.TryParse(tmIndexInput, out double tmIndex))
        {
            chartDataAvailable = false;
            Console.WriteLine("Некорректный ввод номера ТМ.");
            return;
        }

        // Шаг 1: Извлекаем данные по IndexTM
        IQueryable<TMValues> query = _context.telemetry_values.Where(tv => tv.IndexTM == tmIndex);

        // Выбор входных данных
        var inputData = await _context.telemetry_values
            .Where(tm => tm.IndexTM == tmIndex && tm.experiment_label == "Входные данные")
            .ToListAsync();

        // Фильтрация данных по эксперименту
        List<TMValues> experimentData = new();
        if (!string.IsNullOrEmpty(selectedExperiment))
        {
            experimentData = await _context.telemetry_values
                .Where(tv => tv.IndexTM == tmIndex && tv.experiment_label == selectedExperiment)
                .ToListAsync();
        }

        // Логика фильтрации и прореживания для входных данных
        var filteredInputData = ApplyFilters(inputData);

        // Логика фильтрации и прореживания для экспериментальных данных
        var filteredExperimentData = ApplyFilters(experimentData);
        string chartTitle = $"Индекс ТМ: {filteredInputData[0].IndexTM}, Наименование: {filteredInputData[0].NameTM}";
        string yAxisLabel = GetYAxisLabel(filteredInputData[0].Privyazka);

        // Передача данных в JS для построения графика
        try
        {

            await JS.InvokeVoidAsync("generateChart", chartElement, filteredInputData, filteredExperimentData, chartTitle, yAxisLabel);
            // Обновляем переменные после успешного вызова
            // chartDataAvailable = true;
            // showChart = true;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Ошибка вызова JavaScript: {ex.Message}");
            chartDataAvailable = false;
            showChart = false;
        }
    }

    // Метод для фильтрации и прореживания данных
    private List<T> ApplyFilters<T>(List<T> dataList) where T : TMValues
    {

        // Пример: фильтрация по временному интервалу и применение прореживания
        if (startDate.HasValue && endDate.HasValue)
        {
            dataList = dataList
                .Where(tv => IsWithinTimeInterval(tv.NumberOfSrez))
                .ToList();
        }

        if (pruningInterval > 0)
        {
            dataList = dataList
                .OrderBy(tv => tv.NumberOfSrez)
                .Where((tv, index) => index % pruningInterval == 0)
                .ToList();
        }

        return dataList;
    }

    // Проверка попадания времени в интервал
    private bool IsWithinTimeInterval(string numberOfSrez)
    {
        var timeParts = numberOfSrez.Split('_');
        if (timeParts.Length == 3 &&
            int.TryParse(timeParts[0], out int hours) &&
            int.TryParse(timeParts[1], out int minutes) &&
            int.TryParse(timeParts[2], out int seconds))
        {
            var parsedTime = new TimeSpan(hours, minutes, seconds);
            var startTime = startDate.Value.TimeOfDay;
            var endTime = endDate.Value.TimeOfDay;
            return parsedTime >= startTime && parsedTime <= endTime;
        }
        return false;
    }

    private string GetRowClass(string status)
    {
        return status switch
        {
            "Достоверная" => "status-dostovernaya",
            "Сомнительная" => "status-somnitelnaya",
            "Недостоверная" => "status-nedostovernaya",
            _ => string.Empty
        };
    }
    private async Task ApplyTimeIntervalFilter(int pruningInterval)
    {
        //ValidateDates();
        //isIntervalApplied = true;
        await LoadTMValues(isThinningEnabled, pruningInterval);
    }

    private async Task LoadTMValues(bool isThinningEnabled, int pruningInterval)
    {

        isLoading = true;
        loadingMessage = "Применение заданного интервала...";

        if (pruningInterval <= 0)
        {
            await NotifyUserAsync("pruningInterval должен быть больше 0. Установлено значение по умолчанию.", "info");
            pruningInterval = 1; // Устанавливаем значение по умолчанию
        }

        List<string> filePaths = null;


        try
        {
            List<Guid> sliceIdsInRange = null;
            // Получаем пути файлов и идентификаторы срезов
            if (startDate.HasValue && endDate.HasValue)
            {
                if (startDate > endDate)
                {
                    await NotifyUserAsync(
                       "Начальная дата не может быть позже конечной, измеите значение интервала", "error");
                    isLoading = false;
                    return;
                }

                filePaths = await sliceService.GetFilePathsInRangeAsync(startDate.Value, endDate.Value, originalDataSet);
                if (!filePaths.Any())
                {
                    await NotifyUserAsync("Нет найденных путей файлов для заданного временного интервала.", "error");
                    isLoading = false;
                    return;
                }

                // Получение и сортировка идентификаторов срезов
                sliceIdsInRange = await _context.slices
                    .Where(s => filePaths.Contains(s.SlicePath) && s.experiment_label == originalDataSet)
                    .OrderBy(s => s.SliceName)
                    .Select(s => s.SliceID)
                    .ToListAsync()
                    .ConfigureAwait(false);

                if (!sliceIdsInRange.Any())
                {
                    await NotifyUserAsync("Нет идентификаторов срезов для заданных путей файлов.", "error");
                    isLoading = false;
                    return;
                }
            }
            else
            {
                await NotifyUserAsync("Используется полный набор данных, так как временной интервал не задан.", "warning");

                // Получение и сортировка идентификаторов срезов
                sliceIdsInRange = await _context.slices
                    .Where(s => s.experiment_label == originalDataSet)
                    .OrderBy(s => s.SliceName)
                    .Select(s => s.SliceID)
                    .ToListAsync()
                    .ConfigureAwait(false);

                if (!sliceIdsInRange.Any())
                {
                    await NotifyUserAsync("Нет идентификаторов срезов для текущих условий.", "error");
                    isLoading = false;
                    return;
                }
            }

            if (pruningInterval > sliceIdsInRange.Count)
            {
                await NotifyUserAsync(
                    "Заданный интервал прореживания превышает количество доступных срезов. Установите меньшее значение.",
                    "error"
                );
                isLoading = false;
                return;
            }

            // Прореживание идентификаторов срезов, если включено прореживание
            if (isThinningEnabled)
            {
                sliceIdsInRange = sliceIdsInRange
                    .Where((id, index) => index % pruningInterval == 0)
                    .ToList();
            }

            // Формирование запроса с фильтрацией
            IQueryable<TMValues> filteredTMValuesQuery = _context.telemetry_values
                .AsNoTracking()
                .Where(t => sliceIdsInRange.Contains(t.SliceID));


            // Выполнение запроса и обработка данных
            filteredTMValues = await filteredTMValuesQuery
                .Select(t => new TMValues
                    {
                        ID = t.ID,
                        IndexTM = t.IndexTM,
                        IzmerValue = t.IzmerValue,
                        OcenValue = t.OcenValue,
                        Id1 = t.Id1,
                        NameTM = t.NameTM,
                        Lagranj = t.Lagranj,
                        NumberOfSrez = t.NumberOfSrez
                    })
                .ToListAsync();

            if (!filteredTMValues.Any())
            {
                await NotifyUserAsync("Нет данных в TMValues после фильтрации.", "error");
                isLoading = false;
                return;
            }

            isLoading = false;
            isIntervalApplied = true;
            // Обновляем данные для графика
            UpdateChartSourceData(filteredTMValues);

            await NotifyUserAsync($"Загружено {filteredTMValues.Count} записей после применения фильтрации и прореживания.", "info");
            //isIntervalApplied = true;
        }
        catch (OutOfMemoryException)
        {
            await NotifyUserAsync("Заданный интервал слишком велик. Попробуйте обновить страницу и задать меньший диапазон времени или увеличить шаг прореживания срезов.", "error");
            isLoading = false;
            return;
        }

    }

    private async Task NotifyUserAsync(string message, string type = "info", int duration = 5000)
    {
        await InvokeAsync(() =>
        {
            CurrentUserMessage = new UserMessageModel
                {
                    Text = message,
                    Type = type
                };
            StateHasChanged();
        });

        await Task.Delay(duration - 500); // Ждем заданное время, минус длительность анимации

        await InvokeAsync(async () => await HideMessageAsync());
    }


    private string GetAlertClass(string type) => type switch
    {
        "error" => "alert alert-danger",  // Красный фон для ошибок
        "warning" => "alert alert-warning", // Желтый фон для предупреждений
        "info" => "alert alert-info",      // Синий фон для информационных сообщений
        "success" => "alert alert-success", // Зеленый фон для успешных сообщений
        _ => "alert alert-secondary"       // Серый фон по умолчанию
    };

    private async Task HideMessageAsync()
    {
        IsMessageHiding = true; // Устанавливаем флаг для добавления класса .alert-hidden
        await InvokeAsync(StateHasChanged); // Обновляем интерфейс в контексте диспетчера
        await Task.Delay(500);  // Ждем завершения анимации (время из transition)
        await InvokeAsync(() =>
        {
            CurrentUserMessage = null; // Убираем сообщение
            IsMessageHiding = false;   // Сбрасываем флаг
            StateHasChanged();         // Обновляем интерфейс
        });
    }


    private void UpdateChartSourceData(List<TMValues> data)
    {
        chartSourceData = data.ToList();
        Console.WriteLine($"Найдено {data.Count} значений после фильтрации по времени.");
    }


    private void ToggleSelectedActions()
    {
        showModal = !showModal;
    }

    private void CloseModal()
    {
        showModal = false;
    }

    void AddToSelectedActions(VerificationAction action)
    {
        // Проверяем, что комбинация TelemetryId и Id1 уникальн
        if (!selectedActions.Any(a => a.TelemetryId == action.TelemetryId && a.Id1 == action.Id1))
        {
            selectedActions.Add(action);
        }
    }

    private async Task ConfirmActions(List<TMValues> tmValues)
    {
        // Создаем новый список для действий, включая каждую запись из selectedActions
        List<VerificationAction> actionsToExecute = selectedActions
    .Select(action => new VerificationAction
        {
            ActionName = action.ActionName,
            TelemetryId = action.TelemetryId,
            Id1 = action.Id1,
            StartDate = action.StartDate,
            EndDate = action.EndDate,
            CalculationFormula = action.ActionName == "Создать дорасчет"
                                     ? formulas.FirstOrDefault(f => f.StartsWith($"{action.TelemetryId}:"))?.Split(':')[1]
                                     : null // Применяем формулу только для "Создать дорасчет"
        })
    .ToList();


        // Выполнение действий через ActionService
        await ActionService.ExecuteAction(
            actionsToExecute,
            tmValues,
            experimentalKit,
            UpdateProgress,
            SetStatusBarVisible,
            applyFgo
        );

        // Принудительно обновляем данные
        await RefreshDataAfterExperiment();

        // Очищаем выбранные действия и закрываем модальное окно
        //selectedActions.Clear();
        showModal = false;
        // Уведомление об успешном завершении всех операций
        await NotifyUserAsync("Изменения успешно применены, а корреляция рассчитана.", "success");
        Console.WriteLine("Выбранные действия успешно выполнены.");
        isActionConfirmed = true;
        ToggleMonitoringOptions();
    }

    private async Task RefreshDataAfterExperiment()
    {
        availableValues = await _context.telemetry_values
            .Where(tm =>
                !tm.experiment_label.StartsWith("Подготовленные") &&
                !tm.experiment_label.StartsWith("Входные"))
            .Select(tm => tm.experiment_label)
            .Distinct()
            .ToListAsync();

        availableExperiments = availableValues;

        // Принудительно обновляем интерфейс
        await InvokeAsync(StateHasChanged);
    }


    private async Task SetFilteredTMValues(List<TMValues> values)
    {
        // Сохраняем исходное состояние, если оно ещё не сохранено
        if (originalTMValues == null)
        {
            originalTMValues = new List<TMValues>(filteredTMValues);
        }

        // Обновляем основной список
        filteredTMValues = values;

        // Разделяем данные в зависимости от контекста (ручной ввод или выбор)
        if (isManualInput)
        {
            manualTMValues = new List<TMValues>(values);
        }
        else
        {
            selectedTMValues = new List<TMValues>(values);
        }

        await InvokeAsync(StateHasChanged); 
    }



    private async Task SelectAction(NedostovernayaTM telemetry, string action)
    {

        if (!string.IsNullOrEmpty(action) && startDate.HasValue && endDate.HasValue)
        {
            // Проверяем, существует ли уже действие с таким же TelemetryId и Id1
            var existingAction = selectedActions.FirstOrDefault(a => a.TelemetryId == (int)telemetry.IndexTm && a.Id1 == (int)telemetry.Id1);

            if (existingAction != default)
            {
                // Удаляем существующую запись, если она совпадает по TelemetryId и Id1
                selectedActions.Remove(existingAction);
            }

            // Добавляем новое действие для текущего TelemetryId и Id1
            selectedActions.Add(new VerificationAction
                {
                    TelemetryId = (int)telemetry.IndexTm,
                    Id1 = (int)telemetry.Id1,
                    ActionName = action,
                    StartDate = startDate.Value,
                    EndDate = endDate.Value
                });
        }
        else if (string.IsNullOrEmpty(action))
        {
            // Удаляем все действия, если пользователь выбрал пустое значение, по сочетанию TelemetryId и Id1
            selectedActions.RemoveAll(a => a.TelemetryId == (int)telemetry.IndexTm && a.Id1 == (int)telemetry.Id1);
        }
        else
        {
            await NotifyUserAsync("Не введены даты начала и конца интервала для проведеня эксперимента, введите пожалуйста их для продолжения операции.", "error");
            isLoading = false;
            return;
        }
    }

    private void ShowTrackingOptions()
    {
        // Здесь можно открыть выпадающий список с вариантами отслеживания
        isTrackingOptionsVisible = true;
    }

    private void ToggleDropdown()
    {
        isDropdownVisible = !isDropdownVisible;
    }

    private void SelectOriginalDataSet(string dataSet)
    {
        originalDataSet = dataSet;
        isDropdownVisible = false; // Закрыть выпадающий список 
        Console.WriteLine($"Выбран набор данных: {originalDataSet}");
    }


    public async Task<List<string>> GetUniqueExperimentLabels()
    {
        var labels = await _context.telemetry_values
            .Where(tm => !tm.experiment_label.StartsWith("Эксперимент"))
            .Select(tm => tm.experiment_label)
            .Distinct()
            .ToListAsync();
        return labels;
    }

}


@if (showTimeIntervalInput)
{
    <div class="mb-3">
        <label>Начало временного промежутка:</label>
        <input type="datetime-local" @bind="startDate" class="form-control" style= "width: 300px;" />
        <label>Конец временного промежутка:</label>
        <input type="datetime-local" @bind="endDate" class="form-control" style="width: 300px;" />

        <div class="form-check mb-3">
            <input type="checkbox" id="enableThinning" class="form-check-input" @bind="isThinningEnabled" />
            <label class="form-check-label" for="enableThinning">Прореживать данные</label>
        </div>

        @if (isThinningEnabled)
        {
            <div class="mb-3">
                <label>Интервал прореживания:</label>
                <input type="number" @bind="pruningInterval" min="1" class="form-control" style="width: 80px;" />
            </div>
        }

        <div class="mb-3">
            <button class="btn btn-secondary dropdown-toggle" @onclick="ToggleDropdown">
                Выбрать исходный набор данных
            </button>
            @if (isDropdownVisible)
            {
                <div class="dropdown-menu show">
                    @foreach (var label in experimentLabels)
                    {
                        <button class="dropdown-item" @onclick="() => SelectOriginalDataSet(label)">
                            @label
                        </button>
                    }
                </div>
            }
        </div>

        <div class="mt-2">
            <button @onclick="() => ApplyTimeIntervalFilter(pruningInterval)" class="btn btn-primary">
                Применить заданный интервал
            </button>
        </div>
    </div>
}

<h2>Поиск некорректной ТМ</h2>

<button @onclick="() => showTimeIntervalInput = !showTimeIntervalInput" class="btn btn-primary mt-2">
    @(showTimeIntervalInput ? "Скрыть выбор времени" : "Показать выбор времени")
</button>


<!-- Кнопка для запуска расчёта корреляции для всех ТМ -->
<button @onclick="OnCalculateCorrelation" class="btn btn-primary mt-2"
        disabled="@(!isIntervalApplied || isCalculating)">
    Рассчитать корреляцию
</button>


<!-- Кнопка для остановки расчёт -->
<button @onclick="OnStopCalculation" class="btn btn-danger mt-2" disabled="@(!isIntervalApplied || isCalculating == false)">
    Остановить расчет
</button>

@if (isStatusBarVisible)
{
    <div class="progress mt-3">
        <div class="progress-bar progress-bar-striped progress-bar-animated"
             role="progressbar"
             style="width: @currentProgress%"
             aria-valuenow="@currentProgress"
             aria-valuemin="0"
             aria-valuemax="100">
            @currentProgress%
        </div>
    </div>
}

@code {
    private bool isCalculating = false;
    private bool isStatusBarVisible = false;
    private int currentProgress = 0;
    private CancellationTokenSource cancellationTokenSource;

    // Метод расчета корреляции для всех ТМ
    private async Task OnCalculateCorrelation()
    {
        // Проверяем, запущен ли расчет
        if (isCalculating) return;

        // Загружаем все данные ТМ, если `filteredTMValues` не задан
        var tmValues = filteredTMValues ?? await MonitoringService.MonitorAllTMAsync(filteredTMValues);

        await ExecuteCorrelationCalculation(tmValues);

        isLoading = true;
        loadingMessage = "Данные обновляются";

        await InvokeAsync(StateHasChanged); // Убедитесь, что интерфейс обновлен
        isLoading = false;
    }

    // Метод расчета корреляции для отфильтрованных ТМ (используется в ApplyChangesAndCalculateCorrelation)
    private async Task OnCalculateCorrelation(List<TMValues> tmValues)
    {
        if (isCalculating) return;
        await ExecuteCorrelationCalculation(tmValues);
        await InvokeAsync(StateHasChanged); // Убедитесь, что интерфейс обновлен
    }

    // Общий метод для расчета корреляции
    private async Task ExecuteCorrelationCalculation(List<TMValues> tmValues)
    {
        isCalculating = true;
        isStatusBarVisible = true;
        cancellationTokenSource = new CancellationTokenSource();

        await InvokeAsync(StateHasChanged);

        try
        {
            // Запускаем расчет корреляции с учетом фильтрации данных
            await corr.CalculationCorrelation(
                tmValues,                // Передаем значения ТМ для расчета
                UpdateProgress,          // Метод для обновления прогресса
                SetStatusBarVisible,     // Метод для управления видимостью статусбара
                originalDataSet,
                startDate,               // Начальная дата
                endDate,                 // Конечная дата
                cancellationTokenSource.Token
            );

            // Обновляем данные для таблицы
            filteredTm = await _context.correlation_coefficients
                .AsNoTracking()
                .Where(t => t.experiment_label == "Входные данные")
                .ToListAsync();

            await InvokeAsync(StateHasChanged); // Обновляем интерфейс

        }
        catch (OperationCanceledException)
        {
            Console.WriteLine("Расчет был остановлен.");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Ошибка при расчете корреляции: {ex.Message}");
        }
        finally
        {
            isCalculating = false;
            isStatusBarVisible = false;
            cancellationTokenSource.Dispose();


            await InvokeAsync(StateHasChanged);

        }
    }

    // Метод для обновления прогресса
    private void UpdateProgress(int progress)
    {
        InvokeAsync(() =>
        {
            currentProgress = progress;
            StateHasChanged();
        });
    }

    // Метод для управления видимостью статусбара
    private void SetStatusBarVisible(bool isVisible)
    {
        InvokeAsync(() =>
        {
            isStatusBarVisible = isVisible;
            StateHasChanged();
        });
    }

    private async Task OnStopCalculation()
    {
        if (cancellationTokenSource != null)
        {
            // Останавливаем текущий расчет
            cancellationTokenSource.Cancel();
            cancellationTokenSource.Dispose();
            cancellationTokenSource = null;
        }

        // Обновляем состояние интерфейса
        isCalculating = false;
        isStatusBarVisible = false;
        await InvokeAsync(StateHasChanged);
    }


    // Метод для применения изменений и расчета корреляции для отфильтрованных ТМ
    private async Task ApplyChangesAndCalculateCorrelation()
    {
        try
        {
            foreach (var action in selectedActions)
            {

                if (action.ActionName.Contains("Создать дорасчет"))
                {

                    // Проверка: список формул пуст
                    if (formulas == null || !formulas.Any())
                    {
                        await NotifyUserAsync("Формулы для расчёта корреляции не указаны.", "error");
                        return;
                    }

                    // Список для хранения ошибок
                    var errors = new List<string>();

                    // Регулярное выражение для проверки формата формулы
                    var formulaRegex = new Regex(@"^[\+\-\*/]?(\b[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\b)([\+\-\*/]\b[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\b)*$");

                    // Проверяем формулы перед расчётом
                    foreach (var formula in formulas)
                    {
                        // Формат: "TelemetryId:formula"
                        var parts = formula.Split(':');
                        if (parts.Length != 2)
                        {
                            errors.Add($"Некорректный формат формулы: {formula}");
                            continue; // Продолжаем проверку остальных формул
                        }

                        var telemetryId = parts[0];
                        var formulaValue = parts[1];

                        if (string.IsNullOrWhiteSpace(formulaValue))
                        {
                            errors.Add($"Формула для TelemetryId {telemetryId} не указана.");
                            continue;
                        }

                        // Проверяем соответствие формулы регулярному выражению
                        if (!formulaRegex.IsMatch(formulaValue))
                        {
                            errors.Add($"Формула для TelemetryId {telemetryId} имеет некорректный формат: {formulaValue}");
                            continue;
                        }
                    }

                    // Если есть ошибки, уведомляем пользователя и завершаем выполнение
                    if (errors.Any())
                    {
                        foreach (var error in errors)
                        {
                            await NotifyUserAsync(error, "error");
                        }
                        return;
                    }
                }
            }
        
            isCalculating = true;

            // Подтверждаем действия для текущего списка
            ConfirmActions(filteredTMValues);            
       
            // Получаем последнюю метку эксперимента
            var latestExperimentLabel = await MonitoringService.GetNextExperimentLabelAsync();

            // Инициализируем новый класс
            var experimentCorrData = new ExperimentCorrData(_context);

            // Объединяем наборы из выпадающего списка и вручную введённые номера ТМ
            var selectedTMValues = filteredTMValues;

            if (manualTMInputNumbers != null && manualTMInputNumbers.Any())
            {
                // Преобразуем номера из ручного ввода в список TMValues
                var manualTMValues = await MonitoringService.ManualMonitorSetupAsync(manualTMInputNumbers, selectedTMValues.ToList());

                // Объединяем списки и удаляем дубликаты
                selectedTMValues = selectedTMValues
                    .Union(manualTMValues)
                    .GroupBy(tm => new { tm.IndexTM, tm.Id1, tm.Privyazka })
                    .Select(group => group.First())
                    .ToList();
            }

        }
        catch (Exception ex)
        {
            await NotifyUserAsync($"Ошибка при выполнении операции: {ex.Message}", "danger");
            return;
        }
        finally
        {
            // Восстанавливаем исходное состояние из originalTMValues
            if (originalTMValues != null)
            {
                filteredTMValues = originalTMValues;
                originalTMValues = null; // Сбрасываем оригинал после восстановления
            }
            isCalculating = false;
        }

        await LoadData();
        await InvokeAsync(StateHasChanged);
    }

    private async Task HandleExperimentChange(ChangeEventArgs e)
    {
        // Получаем значение из выпадающего списка
        var newSelectedExperiment = e.Value?.ToString();

        // Проверяем, отличается ли новый эксперимент от текущего experimentalKit
        if (experimentalKit != newSelectedExperiment)
        {
            // Обновляем experimentalKit на новый эксперимент
            experimentalKit = newSelectedExperiment;
        }
        // Обновляем интерфейс
        await InvokeAsync(StateHasChanged);
    }

    private void UpdateFormula(VerificationAction action, string? newValue)
    {
        if (!string.IsNullOrWhiteSpace(newValue))
        {
            // Обновляем значение формулы в действии
            action.CalculationFormula = newValue;

            // Обновляем или добавляем формулу в список
            formulas.RemoveAll(f => f.StartsWith($"{action.TelemetryId}:"));
            formulas.Add($"{action.TelemetryId}:{newValue}"); // Сохраняем формулу с `TelemetryId`

            Console.WriteLine($"Формула обновлена: {newValue} для TelemetryId: {action.TelemetryId}");
        }
    }

    private void ValidateDates()
    {
        if (!startDate.HasValue || !endDate.HasValue)
        {
            errorMessage = "Не указаны начальная или конечная дата.";
            return;
        }
        else if (startDate > endDate)
        {
            errorMessage = "Начальная дата не может быть позже конечной.";
            return;
        }
        else
        {
            errorMessage = string.Empty; // Сбрасываем сообщение об ошибке, если всё корректно
        }
    }

    private void SortExperimentData(string column)
    {
        if (currentExperimentSortColumn == column)
        {
            // Переключить направление сортировки
            isExperimentSortAscending = !isExperimentSortAscending;
        }
        else
        {
            // Установить новую колонку для сортировки
            currentExperimentSortColumn = column;
            isExperimentSortAscending = true;
        }

        // Сортировка experimentData
        if (experimentData != null)
        {
            if (isExperimentSortAscending)
            {
                experimentData = experimentData.OrderBy(e => GetPropertyValue(e, column)).ToList();
            }
            else
            {
                experimentData = experimentData.OrderByDescending(e => GetPropertyValue(e, column)).ToList();
            }
        }
    }
    private static object GetPropertyValue(object obj, string propertyName)
    {
        return obj.GetType().GetProperty(propertyName)?.GetValue(obj, null);
    }
}


@if (!string.IsNullOrEmpty(errorMessage))
{
    <div class="alert alert-danger mt-2">
        @errorMessage
    </div>
}

<div>
    <button @onclick="ShowChartInput" class="btn btn-primary mt-2 mb-2"  disabled="@(!isIntervalApplied)">
        Показать график корреляции</button>
</div>

@if (showSearch)
{
    <div class="mb-3">
        <input @bind="searchTerm" placeholder="Поиск по полю Индекс ТМ" class="form-control" />
        <button @onclick="SearchData" class="btn btn-primary mt-2">Искать</button>
        <button @onclick="ResetSearch" class="btn btn-secondary mt-2 ml-2">Сбросить</button>
    </div>
}

@if (showChart)
{
    <div class="mt-4">
        <canvas id="chart" width="400" height="200" @ref="chartElement"></canvas>
    </div>
}

@if (showChartInput)
{
    <div class="mb-3">
        @* <canvas id="chart" width="400" height="200" @ref="chartElement"></canvas> *@
        <input @bind="tmIndexInput" placeholder="Введите номер ТМ" class="form-control" />
        <button @onclick="GenerateChart" class="btn btn-primary mt-2">Построить график</button>
    </div>
}

@if (chartDataAvailable && showChart)
{
    <div class="mt-4">
        @* <canvas id="chart" width="400" height="200" @ref="chartElement"></canvas> *@
        <button @onclick="HideChart" class="btn btn-secondary mb-2">Закрыть график</button>
    </div>
}

<!-- Кнопка для показа выбранных действий -->
@if (selectedActions.Any())
{
    <button class="btn btn-primary mt-2 mb-2 me-2" @onclick="ToggleSelectedActions">Показать выбранные действия</button>
}

@if (showModal)
{
    <div class="alert alert-info mt-3 position-relative">
        <h5>Выбранные действия</h5>
        <h6>Выбранный интервал: от @startDate.Value.ToString("g") до @endDate.Value.ToString("g")</h6>
        
        <!-- Фильтр по экспериментам -->
        <div class="form-group">
            <label for="experimentSelect">Выбрать набор для применения изменений:</label>
            <select id="experimentSelect" class="form-select" @onchange="HandleExperimentChange" style="width: 300px;">
                @foreach (var experiment in availableValues)
                {
                    <option value="@experiment">@experiment</option>
                }
            </select>
        </div>

        <div class="form-check mt-3">
            <input class="form-check-input" type="checkbox" id="applyFgoCheckbox" @bind="applyFgo">
            <label class="form-check-label" for="applyFgoCheckbox">
                Применять ФГО RastrWin3 при внесении изменений
            </label>
            <span class="info-icon" data-bs-toggle="tooltip" title="Применение встроенного фильтра грубых ошибок, реализованного в RastrWin 3 позволяет производить дополнительную отбраковку недостоверной ТМ и приводит к перерасчету небалансов мощности в узлах">
                &#9432;
            </span>
        </div>

        <!-- Включаем JavaScript для активации всплывающей подсказки -->
        <script>
            document.addEventListener('DOMContentLoaded', function () {
                const tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
                const tooltipList = tooltipTriggerList.map(function (tooltipTriggerEl) {
                    return new bootstrap.Tooltip(tooltipTriggerEl);
                });
            });
        </script>

        <style>
            .info-icon {
                margin-left: 8px;
                color: #0d6efd; /* Синий цвет */
                cursor: pointer;
                font-size: 1.2em;
                font-weight: bold; /* Делаем значок жирнее */
            }

                .info-icon:hover {
                    color: #0b5ed7; /* Более темный синий при наведении */
                }
        </style>


        <!-- Таблица с выбранными действиями -->
        <table class="table table-bordered mt-3">
            <thead>
                <tr>
                    <th>Индекс ТМ</th>
                    <th>Узел</th>
                    <th>Действие</th>
                </tr>
            </thead>
            <tbody>
                @foreach (var action in selectedActions)
                {
                    <tr>
                        <td>@action.TelemetryId</td>
                        <td>@action.Id1</td>
                        <td>@action.ActionName
                        </td>
                    </tr>

                    @if (action.ActionName == "Создать дорасчет")
                    {
                        <tr>
                            <td colspan="3">
                                <label for="calculationFormulaInput" class="form-label">Введите дорасчетную формулу:</label>
                                <input id="calculationFormulaInput" type="text" class="form-control"
                                       placeholder="Пример: XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX+...-..."
                                       value="@action.CalculationFormula"
                                       @onchange="(e) => UpdateFormula(action, e.Value?.ToString())" />
                            </td>
                        </tr>
                    }
                }

            </tbody>
        </table>

        <!-- Кнопка для выбора отслеживаемых телеизмерений и расчета корреляции -->
        <div class="mt-3">
            <!-- Кнопка для выбора отслеживаемых телеизмерений -->
            <button class="btn btn-primary dropdown-toggle" type="button" @onclick="ToggleMonitoringOptions" aria-expanded="false">
                Выбрать отслеживаемые телеизмерения
            </button>
            @if (showOptions)
            {
                <ul class="dropdown-menu show">
                    <li>
                        <a class="dropdown-item"
                           @onclick="async () =>
                        {
                            var newValues = await MonitoringService.MonitorAllTMAsync(filteredTMValues.ToList());
                            await SetFilteredTMValues(newValues);
                            ToggleMonitoringOptions();
                        }">
                            Отслеживать изменения для всех ТМ
                        </a>
                    </li>
                    <li>
                        <a class="dropdown-item"
                           @onclick="async () =>
                        {
                            var newValues = await MonitoringService.MonitorUnreliableAndQuestionableTMAsync(filteredTMValues.ToList());
                            await SetFilteredTMValues(newValues);
                            ToggleMonitoringOptions();
                        }">
                            Отслеживать изменения для недостоверных и сомнительных ТМ
                        </a>
                    </li>
                    <li>
                        <a class="dropdown-item"
                           @onclick="async () =>
                        {
                            var newValues = await MonitoringService.MonitorUnreliableTMAsync(filteredTMValues.ToList());
                            await SetFilteredTMValues(newValues);
                            ToggleMonitoringOptions();
                        }">
                            Отслеживать изменения для недостоверных ТМ
                        </a>
                    </li>
                    <li>
                        <a class="dropdown-item"
                           @onclick="async () =>
                           {
                                var telemetryKeys = selectedActions
                                    .Select(a => (a.TelemetryId, a.Id1))
                                    .ToList();

                                var newValues = await MonitoringService.MonitorVerifiedTMAsync(telemetryKeys, filteredTMValues.ToList());

                                // Передача обновлённого списка
                                await SetFilteredTMValues(newValues);

                               ToggleMonitoringOptions();
                           }">
                            Отслеживать изменения для ТМ, которые были достоверизованы
                        </a>
                    </li>
                </ul>
            }

            <div>
                <button class="btn btn-secondary mt-2" @onclick="OpenManualMonitorModal">Задать список отслеживаемых ТМ вручную</button>
            </div>

        </div>
        @if (showManualMonitorModal)
        {
            <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons/font/bootstrap-icons.css" rel="stylesheet">
            <!-- Модальное окно для ручного ввода списка отслеживаемых ТМ -->
            <div class="modal d-block" tabindex="-1">
                <div class="modal-dialog">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title">Введите номера ТМ для отслеживания</h5>
                            <button type="button" class="btn-close" @onclick="CloseManualMonitorModal"></button>
                        </div>
                        <div class="modal-body">
                            <!-- Информационное сообщение с иконкой -->
                            <div class="mb-2 d-flex align-items-center">
                                <i class="bi bi-info-circle text-primary me-2"></i>
                                <span class="text-muted">
                                    Введите интересующие вас номера ТМ через запятую.
                                </span>
                            </div>
                            <!-- Поле ввода номеров ТМ -->
                            <input type="text" class="form-control" @bind="manualTMInput" placeholder="Введите номера ТМ через запятую">
                            @if (!string.IsNullOrEmpty(errorMessage))
                            {
                                <div class="text-danger mt-2">@errorMessage</div>
                            }
                        </div>
                        <div class="modal-footer">
                            <!-- Кнопка отмены -->
                            <button type="button" class="btn btn-secondary" @onclick="CloseManualMonitorModal">Отмена</button>
                            <!-- Кнопка подтверждения ручного ввода -->
                            <button type="button" class="btn btn-primary" @onclick="ValidateAndSubmitManualTMInput">
                                Подтвердить только введённые вручную ТМ
                            </button>
                            <!-- Кнопка объединения -->
                            @if (selectedTMValues.Any() || !string.IsNullOrEmpty(manualTMInput))
                            {
                                <button class="btn btn-primary" @onclick="async () => await CombineAndSubmitSets()">
                                    Добавить к имеющимся
                                </button>
                            }
                            
                        </div>
                    </div>
                </div>
            </div>
        }

        <!-- Объединенная кнопка для применения изменений и расчета корреляции -->
        <div class="mt-3">
            <button class="btn btn-primary mt-2" @onclick="ApplyChangesAndCalculateCorrelation" disabled="@isCalculating">
                Применить изменения и рассчитать корреляцию для отслеживаемых ТМ
            </button>
        </div>


        <div style="position: absolute; bottom: 10px; right: 10px;">
            <button class="btn btn-secondary" @onclick="CloseModal">Закрыть</button>
        </div>
    </div>
}

@code {
    private bool showOptions = false;

    private void ToggleMonitoringOptions()
    {
        isManualInput = false;
        showOptions = !showOptions;
    }

    private void OpenManualMonitorModal()
    {
        showManualMonitorModal = true;
        errorMessage = string.Empty;
    }

    private void CloseManualMonitorModal()
    {
        showManualMonitorModal = false;
        manualTMInput = string.Empty;
        errorMessage = string.Empty;
    }

    private async Task ValidateAndSubmitManualTMInput()
    {
        isManualInput = true; // Указываем, что данные вводятся вручную

        try
        {
            // Вызываем валидацию через ValidationService
            var validationResult = await ValidationService.ValidateTMInputAsync(manualTMInput);

            if (!validationResult.IsValid)
            {
                errorMessage = string.Join("; ", validationResult.Errors);
                return;
            }

            // Преобразуем список строк в список целых чисел
            var tmNumbers = validationResult.TMNumbers.Select(int.Parse).ToList();

            // Сбрасываем filteredTMValues к исходному состоянию
            if (originalTMValues != null)
            {
                filteredTMValues = new List<TMValues>(originalTMValues);
            }

            // Если валидация прошла успешно, выполняем логику для отслеживания
            var filteredTMValuesAfterValidation =
                await MonitoringService.ManualMonitorSetupAsync(tmNumbers, filteredTMValues.ToList());

            // Если найденных значений нет, выводим сообщение
            if (filteredTMValuesAfterValidation == null || !filteredTMValuesAfterValidation.Any())
            {
                errorMessage = "Не найдено подходящих значений.";
                return;
            }

            // Передаём результат в SetFilteredTMValues для обновления интерфейса
            await SetFilteredTMValues(filteredTMValuesAfterValidation);

            // Закрываем модальное окно
            CloseManualMonitorModal();
        }
        catch (Exception ex)
        {
            // Логируем ошибку и выводим сообщение
            Console.WriteLine($"Ошибка при ручной настройке мониторинга: {ex.Message}");
            errorMessage = "Произошла ошибка при обработке данных. Попробуйте снова.";
        }
    }

    private async Task CombineAndSubmitSets()
    {
        // Обрабатываем ввод вручную перед объединением
        await ValidateAndSubmitManualTMInput();

        // Проверяем, если данные готовы
        if (selectedTMValues.Any() && manualTMValues.Any())
        {
            // Объединяем наборы
            var combinedSet = await MonitoringService.CombineMonitoringSetsAsync(selectedTMValues, manualTMValues);

            // Обновляем интерфейс
            await SetFilteredTMValues(combinedSet);

            // Закрываем модальное окно
            CloseManualMonitorModal();
            await InvokeAsync(StateHasChanged);
        }
    }

    private string GetSelectedAction(int telemetryId, int id1)
    {
        var action = selectedActions.FirstOrDefault(a => a.TelemetryId == telemetryId && a.Id1 == id1);
        return action?.ActionName ?? string.Empty;
    }

    private async Task ToggleExperimentForm()
    {
        showExperimentForm = !showExperimentForm;
        if (showExperimentForm && experimentData == null)
        {
            await LoadExperimentData();
            StateHasChanged(); // Уведомляем Blazor об изменении состояния
        }
    }

    private async Task LoadExperimentData()
    {
        var experiments = await _context.experiment
     .Include(e => e.ValidatedTelemetries) // Загрузка связанных данных
     .OrderBy(e => e.id_experiment)
     .ToListAsync();

        // Инициализируем список для отображения данных
        experimentData = new List<ExperimentViewModel>();

        foreach (var experiment in experiments)
        {
            // Проходимся по каждому телеизмерению, связанному с текущим экспериментом
            foreach (var valTm in experiment.ValidatedTelemetries)
            {
                experimentData.Add(new ExperimentViewModel
                    {
                        ExperimentNumber = experiment.experiment_label,
                        DateExperiment = experiment.date_experiment, // Приведение даты к строке
                        CalculationInterval = $"от {experiment.start_date_experiment_interval} до {experiment.end_date_experiment_interval}",
                        ApplyFGO = experiment.apply_fgo,
                        TelemetryNumber = valTm.index_tm,
                        RecommendedAction = valTm.recomended_action
                    });
            }
        }
        Console.WriteLine($"Данные загружены: {experimentData.Count} записей.");
    }

    private void CloseExperimentForm()
    {
        showExperimentForm = false;
    }

}

@if (availableExperiments.Any() )
{
    <button class="btn btn-primary mt-2 mb-2" @onclick="ToggleExperimentForm">Проведенные эксперименты</button>
}

@if (showExperimentForm)
{
    <div class="alert alert-info mt-3 position-relative" style="padding-bottom: 40px; height: auto; min-height: 300px;">
        <h4>Проведенные эксперименты</h4>
        <table class="table table-striped">
            <thead>
                <tr>
                    <th @onclick="() => SortExperimentData(nameof(ExperimentViewModel.ExperimentNumber))" style="cursor: pointer;">
                        Номер эксперимента @(currentExperimentSortColumn == nameof(ExperimentViewModel.ExperimentNumber) ? (isExperimentSortAscending ? "▲" : "▼") : "")
                    </th>
                    <th @onclick="() => SortExperimentData(nameof(ExperimentViewModel.DateExperiment))" style="cursor: pointer;">
                        Дата проведения эксперимента @(currentExperimentSortColumn == nameof(ExperimentViewModel.DateExperiment) ? (isExperimentSortAscending ? "▲" : "▼") : "")
                    </th>
                    <th @onclick="() => SortExperimentData(nameof(ExperimentViewModel.CalculationInterval))" style="cursor: pointer;">
                        Расчетный интервал @(currentExperimentSortColumn == nameof(ExperimentViewModel.CalculationInterval) ? (isExperimentSortAscending ? "▲" : "▼") : "")
                    </th>
                    <th @onclick="() => SortExperimentData(nameof(ExperimentViewModel.ApplyFGO))" style="cursor: pointer;">
                        Использование ФГО @(currentExperimentSortColumn == nameof(ExperimentViewModel.ApplyFGO) ? (isExperimentSortAscending ? "▲" : "▼") : "")
                    </th>
                    <th>
                        Номер телеизмерения
                    </th>
                    <th>
                        Действие по достоверизации
                    </th>
                </tr>
            </thead>
            <tbody>
                @if (experimentData == null)
                {
                    <tr>
                        <td colspan="5">Данные загружаются...</td>
                    </tr>
                }
                else
                {
                    @foreach (var group in experimentData.GroupBy(e => e.ExperimentNumber))
                    {
                        <tr>
                            <!-- Отображаем информацию об эксперименте -->
                            <td>@group.Key</td>
                            <td>@group.First().DateExperiment</td>
                            <td>@group.First().CalculationInterval</td>
                            <td>@(group.First().ApplyFGO ? "Да" : "Нет")</td>

                            <!-- Объединяем связанные телеизмерения в одну ячейку -->
                            <td>
                                @foreach (var telemetry in group)
                                {
                                    <div>@telemetry.TelemetryNumber</div>
                                }
                            </td>

                            <!-- Объединяем действия по достоверизации в одну ячейку -->
                            <td>
                                @foreach (var action in group)
                                {
                                    <div>@action.RecommendedAction</div>
                                }
                            </td>
                        </tr>
                    }
                }
            </tbody>
        </table>
        <!-- Кнопка Закрыть -->
        <div style="position: absolute; bottom: 5px; right: 10px;">
            <button class="btn btn-secondary" @onclick="CloseExperimentForm">Закрыть</button>
        </div>
    </div>
}

@if (CurrentUserMessage != null)
{
    <div class="@GetAlertClass(CurrentUserMessage.Type) @(IsMessageHiding ? "alert-hidden" : "")">
        @CurrentUserMessage.Text
    </div>
}

@if (IsDropdownVisible)
{
    <div class="form-group">
        <label for="experimentSelect">Выберите эксперимент:</label>
        <select id="experimentSelect" class="form-select" @onchange="FilterByExperiment" style="width: 200px;">
            <option value="" selected>Входные данные</option>
            @foreach (var experiment in availableExperiments)
            {
                <option value="@experiment">@experiment</option>
            }
            
        </select>
    </div>
}


    @if (isLoading)
    {
        <div class="loading-indicator">
            <div class="spinner-border"></div>
            <p>@loadingMessage</p> <!-- Текст сообщения меняется динамически -->
        </div>
    }

else if (filteredTm == null || !filteredTm.Any())
{
    <p style="margin-top: 20px;">Нет данных для отображения.</p>
}
else
{
    <div style="overflow-y: auto; max-height: 1000px;">
        <table class="table table-bordered" style="position: relative; border-collapse: collapse; width: 100%; padding:0; margin:0">
            <thead style="position: sticky; top: 0; background-color: white; z-index: 2; padding:0; margin:0">
                <!-- Первый уровень заголовков -->
                <tr>
                    <th colspan="8" class="text-center">Входные данные</th>
                    @if (!string.IsNullOrEmpty(selectedExperiment) && selectedExperiment != "Входные данные")
                    {
                        <th colspan="4" class="text-center">Значения экспериментов</th>
                    }
                </tr>
                <!-- Второй уровень заголовков -->
                <tr>
                    <th @onclick="() => SortData(nameof(NedostovernayaTM.ID))">
                        Идентификатор @(currentSortColumn == nameof(NedostovernayaTM.ID) ? (isAscending ? "▲" : "▼") : "")
                    </th>
                    <th>
                        <span @onclick="() => SortData(nameof(NedostovernayaTM.IndexTm))" style="cursor:pointer;">
                            Индекс ТМ @(currentSortColumn == nameof(NedostovernayaTM.IndexTm) ? (isAscending ? "▲" : "▼") : "")
                        </span>
                        <button @onclick="ToggleSearch" class="btn btn-link" style="padding:0; margin-left:5px;">
                            🔍
                        </button>
                    </th>
                    <th @onclick="() => SortData(nameof(NedostovernayaTM.CorrTm))">
                        Узел @(currentSortColumn == nameof(NedostovernayaTM.Id1) ? (isAscending ? "▲" : "▼") : "")
                    </th>
                    <th @onclick="() => SortData(nameof(NedostovernayaTM.CorrTm))">
                        Коэффициент корреляции @(currentSortColumn == nameof(NedostovernayaTM.CorrTm) ? (isAscending ? "▲" : "▼") : "")
                    </th>
                    <th @onclick="() => SortData(nameof(NedostovernayaTM.Status))">
                        Статус @(currentSortColumn == nameof(NedostovernayaTM.Status) ? (isAscending ? "▲" : "▼") : "")
                    </th>
                    <th @onclick="() => SortData(nameof(NedostovernayaTM.MaxLagranj))">
                        Максимальное значение лагранжиана @(currentSortColumn == nameof(NedostovernayaTM.MaxLagranj) ? (isAscending ? "▲" : "▼") : "")
                    </th>
                    <th @onclick="() => SortData(nameof(NedostovernayaTM.AvgLagranj))">
                        Среднее значение лагранжиана @(currentSortColumn == nameof(NedostovernayaTM.AvgLagranj) ? (isAscending ? "▲" : "▼") : "")
                    </th>
                    <th @onclick="() => SortData(nameof(NedostovernayaTM.recomendedActions))">
                        Действия по достоверизации @(currentSortColumn == nameof(NedostovernayaTM.recomendedActions) ? (isAscending ? "▲" : "▼") : "")
                    </th>
                    @if (!string.IsNullOrEmpty(selectedExperiment) && selectedExperiment != "Входные данные")
                    {
                        <th>Коэффициент корреляции</th>
                        <th>Статус</th>
                        <th>Максимальное значение лагранжиана</th>
                        <th>Среднее значение лагранжиана</th>
                    }
                </tr>
            </thead>
            <tbody>
                @foreach (var telemetry in filteredTm)
                {
                    <tr class="@GetRowClass(telemetry.Status)">

                        @if (string.IsNullOrEmpty(selectedExperiment) || selectedExperiment == "Входные данные")
                        {
                            <!-- Входные данные -->
                            <td>@telemetry.ID</td>
                            <td>@telemetry.IndexTm</td>
                            <td>@telemetry.Id1</td>
                            <td>@Math.Round(telemetry.CorrTm, 4)</td>
                            <td>@telemetry.Status</td>
                            <td>@Math.Round(telemetry.MaxLagranj, 4)</td>
                            <td>@Math.Round(telemetry.AvgLagranj, 4)</td>
                        }
                        else
                        {
                            <!-- Данные для выбранного эксперимента -->
                            <td>@GetExperimentValue(telemetry.IndexTm, "Входные данные", "ID")</td>
                            <td>@GetExperimentValue(telemetry.IndexTm, "Входные данные", "IndexTm")</td>
                            <td>@GetExperimentValue(telemetry.IndexTm, "Входные данные", "Id1")</td>
                            <td>@GetExperimentValue(telemetry.IndexTm, "Входные данные", "CorrTm")</td>
                            <td>@GetExperimentValue(telemetry.IndexTm, "Входные данные", "Status")</td>
                            <td>@GetExperimentValue(telemetry.IndexTm, "Входные данные", "MaxLagranj")</td>
                            <td>@GetExperimentValue(telemetry.IndexTm, "Входные данные", "AvgLagranj")</td>
                        }

                        <td>
                            <select class="form-select"
                                    value="@GetSelectedAction((int)telemetry.IndexTm, telemetry.Id1)"
                                    @onchange="(e) => SelectAction(telemetry, e.Value.ToString())">
                                <option value="">Выберите действие</option>
                                <option value="Изменить знак ТМ">Изменить знак ТМ</option>
                                <option value="Создать дорасчет">Создать дорасчет</option>
                                <option value="Исключить из ОС">Исключить из ОС</option>
                            </select>
                        </td>
                        <!-- Добавляем значения для каждого эксперимента -->
                        @if (!string.IsNullOrEmpty(selectedExperiment) && selectedExperiment != "Входные данные")
                        {

                            <td>@GetExperimentValue(telemetry.IndexTm, selectedExperiment, "CorrTm")</td>
                            <td>@GetExperimentValue(telemetry.IndexTm, selectedExperiment, "Status")</td>
                            <td>@GetExperimentValue(telemetry.IndexTm, selectedExperiment, "MaxLagranj")</td>
                            <td>@GetExperimentValue(telemetry.IndexTm, selectedExperiment, "AvgLagranj")</td>
                        }
                    </tr>
                }
            </tbody>
        </table>
    </div>
    <div style="height: 50px;"></div> <!-- Вертикальный отступ -->
}








