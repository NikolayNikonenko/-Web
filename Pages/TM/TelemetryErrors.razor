@page "/nedostovernost"
@using перенос_бд_на_Web.Models
@using Microsoft.EntityFrameworkCore
@using перенос_бд_на_Web.Models
@using перенос_бд_на_Web.Data
@using перенос_бд_на_Web.Services
@using Microsoft.EntityFrameworkCore
@inject SliceService sliceService
@inject ActionService ActionService
@inject TelemetryMonitoringService MonitoringService
@inject ValidationService ValidationService
@inject ApplicationContext _context
@inject CorrData corr
@inject IJSRuntime JS

<PageTitle>Выявленные некорректной ТМ ТМ</PageTitle>

<style>
    .status-dostovernaya {
        background-color: lightgreen;
    }

    .status-somnitelnaya {
        background-color: lightyellow;
    }

    .status-nedostovernaya {
        background-color: lightcoral;
    }
</style>

@code {
    private List<NedostovernayaTM> tm = new List<NedostovernayaTM>();
    private List<NedostovernayaTM> filteredTm = new List<NedostovernayaTM>();
    public List<TMValues> filteredTMValues = new List<TMValues>();
    private List<TMValues> originalTMValues; // Исходный набор данных
    private string currentSortColumn;
    private bool isAscending = true;
    private string searchTerm = string.Empty;
    private bool showSearch = false;
    private bool showChartInput = false;
    private bool showChart = false;
    private string tmIndexInput = string.Empty;
    private List<TMValues> chartData = new List<TMValues>();
    private bool chartDataAvailable = false;
    private ElementReference chartElement;
    private DateTime? startDate;
    private DateTime? endDate;
    private bool showTimeIntervalInput = false;
    private List<NedostovernayaTM> tmData = new List<NedostovernayaTM>();
    private bool showThinningInput = false; // Показывать ли поле для ввода интервала прореживания
    private int pruningInterval = 1; // Интервал прореживания по умолчанию
    private List<TMValues> chartSourceData = new List<TMValues>();
    public bool IsDropdownVisible { get; set; }  // Новое свойство
    private NedostovernayaTM selectedTelemetry; // Хранит выбранный элемент для отображения действий
    private string selectedAction; // Хранит выбранное действие
    private bool showChangeList = false;
    private List<VerificationAction> selectedActions = new();
    private bool showModal = false;
    private bool isActionConfirmed = false;
    private bool isTrackingOptionsVisible;
    private List<TMValues> filteredTMValuesAfterValidation = new List<TMValues>();

    private bool showManualMonitorModal = false;
    private string manualTMInput;
    private string errorMessage;

    private List<TMValues> selectedTMValues = new();
    private List<TMValues> manualTMValues = new();

    private bool isManualInput = false;

    private List<int> manualTMInputNumbers = new List<int>();


    private string selectedExperiment; // Выбранный эксперимент
    private List<string> availableExperiments = new List<string>(); // Список экспериментов




    protected override async Task OnInitializedAsync()
    {
        await LoadData();
    }


    private async Task LoadData()
    {
        try
        {
            // Загружаем все данные из таблицы
            tm = await _context.tm.AsNoTracking().ToListAsync();

            // Фильтруем данные с меткой "Входные данные" для исходной таблицы
            filteredTm = tm.Where(t => t.experiment_label == "Входные данные").ToList();

            // Собираем список уникальных экспериментов (только метки, начинающиеся с "Эксперимент")
            availableExperiments = tm
                .Where(t => t.experiment_label.StartsWith("Эксперимент"))
                .Select(t => t.experiment_label)
                .Distinct()
                .OrderBy(label => label)
                .ToList();

            // Показываем выпадающий список только если есть эксперименты
            IsDropdownVisible = availableExperiments.Any();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error fetching data: {ex.Message}");
        }
    }

    private void SortData(string column)
    {
        if (currentSortColumn == column)
        {
            isAscending = !isAscending;
        }
        else
        {
            currentSortColumn = column;
            isAscending = true;
        }

        filteredTm = column switch
        {
            nameof(NedostovernayaTM.ID) => isAscending ? filteredTm.OrderBy(t => t.ID).ToList() : filteredTm.OrderByDescending(t => t.ID).ToList(),
            nameof(NedostovernayaTM.IndexTm) => isAscending ? filteredTm.OrderBy(t => t.IndexTm).ToList() : filteredTm.OrderByDescending(t => t.IndexTm).ToList(),
            nameof(NedostovernayaTM.Id1) => isAscending ? filteredTm.OrderBy(t => t.Id1).ToList() : filteredTm.OrderByDescending(t => t.Id1).ToList(),
            nameof(NedostovernayaTM.CorrTm) => isAscending ? filteredTm.OrderBy(t => t.CorrTm).ToList() : filteredTm.OrderByDescending(t => t.CorrTm).ToList(),
            nameof(NedostovernayaTM.Status) => isAscending ? filteredTm.OrderBy(t => t.Status).ToList() : filteredTm.OrderByDescending(t => t.Status).ToList(),
            nameof(NedostovernayaTM.MaxLagranj) => isAscending ? filteredTm.OrderBy(t => t.MaxLagranj).ToList() : filteredTm.OrderByDescending(t => t.MaxLagranj).ToList(),
            nameof(NedostovernayaTM.AvgLagranj) => isAscending ? filteredTm.OrderBy(t => t.AvgLagranj).ToList() : filteredTm.OrderByDescending(t => t.AvgLagranj).ToList(),
            _ => filteredTm
        };
    }

    private void SearchData()
    {
        if (string.IsNullOrEmpty(searchTerm))
        {
            filteredTm = tm;
        }
        else
        {
            filteredTm = tm.Where(t => t.IndexTm.ToString().Contains(searchTerm, StringComparison.OrdinalIgnoreCase)).ToList();
        }
        SortData(currentSortColumn);
    }

    private void ToggleSearch()
    {
        showSearch = !showSearch;
        if (!showSearch)
        {
            searchTerm = string.Empty;
            SearchData();
        }
    }

    private void ResetSearch()
    {
        searchTerm = string.Empty;
        filteredTm = tm;
        SortData(currentSortColumn);
    }

    private void ShowChartInput()
    {
        showChartInput = true;
        showChart = false; // Скрыть график при показе ввода для нового графика
    }

    private void HideChart()
    {
        showChart = false;
        chartDataAvailable = false;
    }

    private string GetYAxisLabel(string privyazka)
    {
        return privyazka switch
        {
            "U" => "U, кВ",
            "Pнач" or "Pкон" or "P_ген-р" or "Pген" or "Pнаг" => "P, МВт",
            "Qнач" or "Qкон" or "Q_ген-р" or "Qген" or "Qнаг" => "Q, МВар",
            _ => "Значения"
        };
    }

    private void FilterByExperiment(ChangeEventArgs e)
    {
        selectedExperiment = e.Value?.ToString();

        if (!string.IsNullOrEmpty(selectedExperiment) && selectedExperiment != "Входные данные")
        {
            // Получаем входные данные и экспериментальные данные
            var inputData = tm.Where(t => t.experiment_label == "Входные данные").ToList();
            var experimentData = tm.Where(t => t.experiment_label == selectedExperiment).ToList();

            // Выводим количество записей для входных данных и экспериментальных данных
            Console.WriteLine($"Входных данных: {inputData.Count}, Экспериментальных данных: {experimentData.Count}");

            // Объединяем входные данные и экспериментальные
            filteredTm = inputData
                .Where(input => experimentData.Any(experiment => experiment.IndexTm == input.IndexTm))
                .Select(input =>
                {
                    var experiment = experimentData.First(experiment => experiment.IndexTm == input.IndexTm);

                    return new NedostovernayaTM
                        {
                            ID = input.ID, // Сохраняем оригинальный ID, если он важен
                            IndexTm = input.IndexTm,
                            experiment_label = input.experiment_label,
                            CorrTm = experiment.CorrTm,
                            Status = experiment.Status,
                            MaxLagranj = experiment.MaxLagranj,
                            AvgLagranj = experiment.AvgLagranj,
                            // Добавляем другие свойства, если они есть
                        };
                }).ToList();

            // Выводим отфильтрованные данные
            Console.WriteLine($"Отфильтрованных данных: {filteredTm.Count}");
        }
        else
        {
            // Отображаем только входные данные
            filteredTm = tm.Where(t => t.experiment_label == "Входные данные").ToList();
        }
    }

    public string GetExperimentValue(double indexTm, string experimentLabel, string fieldName)
    {
        // Ищем данные для выбранного эксперимента
        var experimentData = tm
            .FirstOrDefault(t => t.IndexTm == indexTm && t.experiment_label == experimentLabel);

        if (experimentData != null)
        {
            Console.WriteLine($"Данные для эксперимента {experimentLabel} с IndexTm {indexTm} найдены.");

            return fieldName switch
            {
                "CorrTm" => experimentData.CorrTm.ToString("F4"),
                "Status" => experimentData.Status,
                "MaxLagranj" => experimentData.MaxLagranj.ToString("F4"),
                "AvgLagranj" => experimentData.AvgLagranj.ToString("F4"),
                "ID" => experimentData.ID.ToString(), // ID
                "IndexTm" => experimentData.IndexTm.ToString(), // IndexTm
                "Id1" => experimentData.Id1.ToString(), // Id1
                _ => "-" // для других полей возвращаем "-"
            };
        }
        else
        {
            // Если данных для эксперимента нет, проверяем данные для "Входные данные"
            var baselineData = _context.tm
                .FirstOrDefault(t => t.IndexTm == indexTm && t.experiment_label == "Входные данные");

            if (baselineData != null)
            {
                Console.WriteLine($"Данные для входных данных с IndexTm {indexTm} найдены.");

                return fieldName switch
                {
                    "CorrTm" => baselineData.CorrTm.ToString("F4"),
                    "Status" => baselineData.Status,
                    "MaxLagranj" => baselineData.MaxLagranj.ToString("F4"),
                    "AvgLagranj" => baselineData.AvgLagranj.ToString("F4"),
                    "ID" => baselineData.ID.ToString(), // ID
                    "IndexTm" => baselineData.IndexTm.ToString(), // IndexTm
                    "Id1" => baselineData.Id1.ToString(), // Id1
                    _ => "-" // для других полей
                };
            }
        }

        Console.WriteLine($"Не удалось найти данные для IndexTm {indexTm}.");
        return "-"; // Если данных нет
    }


    private async Task GenerateChart()
    {
        if (!double.TryParse(tmIndexInput, out double tmIndex))
        {
            chartDataAvailable = false;
            Console.WriteLine("Некорректный ввод номера ТМ.");
            return;
        }

        // Шаг 1: Извлекаем данные по IndexTM
        IQueryable<TMValues> query = _context.TMValues.Where(tv => tv.IndexTM == tmIndex);

        // Выбор входных данных
        var inputData = await _context.TMValues
            .Where(tm => tm.IndexTM == tmIndex && tm.experiment_label == "Входные данные")
            .ToListAsync();

        // Фильтрация данных по эксперименту
        List<TMValues> experimentData = new();
        if (!string.IsNullOrEmpty(selectedExperiment))
        {
            experimentData = await _context.TMValues
                .Where(tv => tv.IndexTM == tmIndex && tv.experiment_label == selectedExperiment)
                .ToListAsync();
        }

        // Логика фильтрации и прореживания для входных данных
        var filteredInputData = ApplyFilters(inputData);

        // Логика фильтрации и прореживания для экспериментальных данных
        var filteredExperimentData = ApplyFilters(experimentData);
        string chartTitle = $"Индекс ТМ: {filteredInputData[0].IndexTM}, Наименование: {filteredInputData[0].NameTM}";
        string yAxisLabel = GetYAxisLabel(filteredInputData[0].Privyazka);

        // Передача данных в JS для построения графика
        try
        {

            await JS.InvokeVoidAsync("generateChart", chartElement, filteredInputData, filteredExperimentData, chartTitle, yAxisLabel);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Ошибка вызова JavaScript: {ex.Message}");
        }
    }

    // Метод для фильтрации и прореживания данных
    private List<T> ApplyFilters<T>(List<T> dataList) where T : TMValues
    {
        // Пример: фильтрация по временному интервалу и применение прореживания
        if (startDate.HasValue && endDate.HasValue)
        {
            dataList = dataList
                .Where(tv => IsWithinTimeInterval(tv.NumberOfSrez))
                .ToList();
        }

        if (pruningInterval > 0)
        {
            dataList = dataList
                .OrderBy(tv => tv.NumberOfSrez)
                .Where((tv, index) => index % pruningInterval == 0)
                .ToList();
        }

        return dataList;
    }

    // Проверка попадания времени в интервал
    private bool IsWithinTimeInterval(string numberOfSrez)
    {
        var timeParts = numberOfSrez.Split('_');
        if (timeParts.Length == 3 &&
            int.TryParse(timeParts[0], out int hours) &&
            int.TryParse(timeParts[1], out int minutes) &&
            int.TryParse(timeParts[2], out int seconds))
        {
            var parsedTime = new TimeSpan(hours, minutes, seconds);
            var startTime = startDate.Value.TimeOfDay;
            var endTime = endDate.Value.TimeOfDay;
            return parsedTime >= startTime && parsedTime <= endTime;
        }
        return false;
    }

    private string GetRowClass(string status)
    {
        return status switch
        {
            "Достоверная" => "status-dostovernaya",
            "Сомнительная" => "status-somnitelnaya",
            "Недостоверная" => "status-nedostovernaya",
            _ => string.Empty
        };
    }
    private async Task ApplyTimeIntervalFilter(bool isThinning = false)
    {
        if (startDate.HasValue && endDate.HasValue)
        {
            await FilterByTimeInterval(isThinning);
        }
        else
        {
            await RetrieveAllData(isThinning);
        }
    }

    private async Task FilterByTimeInterval(bool isThinning)
    {
        var filePaths = await sliceService.GetFilePathsInRangeAsync(startDate.Value, endDate.Value);

        if (!filePaths.Any())
        {
            Console.WriteLine("Нет найденных путей файлов для заданного временного интервала.");
            return;
        }

        var sliceIdsInRange = await _context.slices
            .Where(s => filePaths.Contains(s.SlicePath))
            .Select(s => s.SliceID)
            .ToListAsync();

        if (!sliceIdsInRange.Any())
        {
            Console.WriteLine("Нет идентификаторов срезов для заданных путей файлов.");
            return;
        }

        filteredTMValues = await _context.TMValues
            .Where(t => sliceIdsInRange.Contains(t.SliceID))
            .ToListAsync();

        if (!filteredTMValues.Any())
        {
            Console.WriteLine("filteredTMValues пуст после фильтрации.");
            return;
        }

        UpdateChartSourceData(filteredTMValues);

        if (isThinning)
        {
            ApplyThinning();
        }
    }

    private async Task RetrieveAllData(bool isThinning)
    {
        filteredTMValues = await _context.TMValues.ToListAsync();
        UpdateChartSourceData(filteredTMValues);

        if (!filteredTMValues.Any())
        {
            Console.WriteLine("Нет данных в TMValues.");
            return;
        }

        if (isThinning)
        {
            ApplyThinning();
        }
    }

    private void UpdateChartSourceData(List<TMValues> data)
    {
        chartSourceData = data.ToList();
        Console.WriteLine($"Найдено {data.Count} значений после фильтрации по времени.");
    }

    private void ApplyThinning()
    {
        if (pruningInterval <= 0)
        {
            Console.WriteLine("thinningInterval должен быть больше 0.");
            return;
        }

        filteredTMValues = filteredTMValues
            .Where((t, index) => index % pruningInterval == 0)
            .ToList();

        UpdateChartSourceData(filteredTMValues);
        Console.WriteLine($"Прореживание данных: осталось {filteredTMValues.Count} значений.");
    }

    private void ToggleSelectedActions()
    {
        showModal = !showModal;
    }

    private void CloseModal()
    {
        showModal = false;
    }

    void AddToSelectedActions(VerificationAction action)
    {
        // Проверяем, что комбинация TelemetryId и Id1 уникальн
        if (!selectedActions.Any(a => a.TelemetryId == action.TelemetryId && a.Id1 == action.Id1))
        {
            selectedActions.Add(action);
        }
    }

    private async Task ConfirmActions(List<TMValues> tmValues)
    {
        // Создаем новый список для действий, включая каждую запись из selectedActions
        List<VerificationAction> actionsToExecute = selectedActions
            .Select(action => new VerificationAction
                {
                    ActionName = action.ActionName,
                    TelemetryId = action.TelemetryId,
                    Id1 = action.Id1,
                    StartDate = action.StartDate,
                    EndDate = action.EndDate
                })
            .ToList();

        // Выполнение действий через ActionService
        await ActionService.ExecuteAction(
            actionsToExecute,
            tmValues,
            UpdateProgress,
            SetStatusBarVisible
        );

        // Очищаем выбранные действия и закрываем модальное окно
        //selectedActions.Clear();
        showModal = false;
        Console.WriteLine("Выбранные действия успешно выполнены.");
        isActionConfirmed = true;
        ToggleMonitoringOptions();
    }


    private async Task SetFilteredTMValues(List<TMValues> values)
    {
        // Сохраняем исходное состояние, если оно ещё не сохранено
        if (originalTMValues == null)
        {
            originalTMValues = new List<TMValues>(filteredTMValues);
        }

        // Обновляем основной список
        filteredTMValues = values;

        // Разделяем данные в зависимости от контекста (ручной ввод или выбор)
        if (isManualInput)
        {
            manualTMValues = new List<TMValues>(values);
        }
        else
        {
            selectedTMValues = new List<TMValues>(values);
        }

        await InvokeAsync(StateHasChanged); // Обновление интерфейса
    }



    private void SelectAction(NedostovernayaTM telemetry, string action)
    {
        if (!string.IsNullOrEmpty(action) && startDate.HasValue && endDate.HasValue)
        {
            // Проверяем, существует ли уже действие с таким же TelemetryId и Id1
            var existingAction = selectedActions.FirstOrDefault(a => a.TelemetryId == (int)telemetry.IndexTm && a.Id1 == (int)telemetry.Id1);

            if (existingAction != default)
            {
                // Удаляем существующую запись, если она совпадает по TelemetryId и Id1
                selectedActions.Remove(existingAction);
            }

            // Добавляем новое действие для текущего TelemetryId и Id1
            selectedActions.Add(new VerificationAction
                {
                    TelemetryId = (int)telemetry.IndexTm,
                    Id1 = (int)telemetry.Id1,
                    ActionName = action,
                    StartDate = startDate.Value,
                    EndDate = endDate.Value
                });
        }
        else if (string.IsNullOrEmpty(action))
        {
            // Удаляем все действия, если пользователь выбрал пустое значение, по сочетанию TelemetryId и Id1
            selectedActions.RemoveAll(a => a.TelemetryId == (int)telemetry.IndexTm && a.Id1 == (int)telemetry.Id1);
        }
    }

    private void ShowTrackingOptions()
    {
        // Здесь можно открыть выпадающий список с вариантами отслеживания
        // Например, можно использовать булеву переменную для контроля видимости списка
        isTrackingOptionsVisible = true;
    }

}

@if (showTimeIntervalInput)
{
    <div class="mb-3">
        <label>Начало временного промежутка:</label>
        <input type="datetime-local" @bind="startDate" class="form-control" />
        <label>Конец временного промежутка:</label>
        <input type="datetime-local" @bind="endDate" class="form-control" />

        @if (showThinningInput)
        {
            <div class="mb-3">
                <label>Интервал прореживания:</label>
                <input type="number" @bind="pruningInterval" min="1" class="form-control" />
            </div>
        }

        <div class="mt-2">
            <button @onclick="() => ApplyTimeIntervalFilter(false)" class="btn btn-primary me-2">Применить заданный интервал</button>
            <button @onclick="() => ApplyTimeIntervalFilter(true)" class="btn btn-secondary">Прореживать данные</button>
        </div>
    </div>
}

<h2>Выявленные некорректной ТМ</h2>

<button @onclick="() => showTimeIntervalInput = !showTimeIntervalInput" class="btn btn-primary mt-2">
    @(showTimeIntervalInput ? "Скрыть выбор времени" : "Показать выбор времени")
</button>

<button @onclick="() => showThinningInput = !showThinningInput" class="btn btn-primary mt-2">
    @(showThinningInput ? "Скрыть интервал прореживания" : "Задать интервал прореживания")
</button>


<!-- Кнопка для запуска расчёта корреляции для всех ТМ -->
<button @onclick="OnCalculateCorrelation" class="btn btn-primary mt-2" disabled="@isCalculating">
    Рассчитать корреляцию
</button>


<!-- Кнопка для остановки расчёта -->
<button @onclick="OnStopCalculation" class="btn btn-danger mt-2" disabled="@(isCalculating == false)">
    Остановить расчет
</button>

@if (isStatusBarVisible)
{
    <!-- Прогресс-бар -->
    <div class="progress mt-4">
        <div class="progress-bar" role="progressbar" style="width: @currentProgress%" aria-valuenow="@currentProgress" aria-valuemin="0" aria-valuemax="100">
            @currentProgress%
        </div>
    </div>
}

@code {
    private bool isCalculating = false;
    private bool isStatusBarVisible = false;
    private int currentProgress = 0;
    private CancellationTokenSource cancellationTokenSource;

    // Метод расчета корреляции для всех ТМ
    private async Task OnCalculateCorrelation()
    {
        // Проверяем, запущен ли расчет
        if (isCalculating) return;

        // Загружаем все данные ТМ, если `filteredTMValues` не задан
        var tmValues = filteredTMValues ?? await MonitoringService.MonitorAllTMAsync(filteredTMValues);
        await ExecuteCorrelationCalculation(tmValues);
    }

    // Метод расчета корреляции для отфильтрованных ТМ (используется в ApplyChangesAndCalculateCorrelation)
    private async Task OnCalculateCorrelation(List<TMValues> tmValues)
    {
        if (isCalculating) return;
        await ExecuteCorrelationCalculation(tmValues);
    }

    // Общий метод для расчета корреляции
    private async Task ExecuteCorrelationCalculation(List<TMValues> tmValues)
    {
        isCalculating = true;
        isStatusBarVisible = true;
        cancellationTokenSource = new CancellationTokenSource();

        await InvokeAsync(StateHasChanged);

        try
        {
            // Запускаем расчет корреляции с учетом фильтрации данных
            await corr.CalculationCorrelation(
                tmValues,                // Передаем значения ТМ для расчета
                UpdateProgress,          // Метод для обновления прогресса
                SetStatusBarVisible,     // Метод для управления видимостью статусбара
                startDate,               // Начальная дата
                endDate,                 // Конечная дата
                false,
                1,
                cancellationTokenSource.Token
            );
        }
        catch (OperationCanceledException)
        {
            Console.WriteLine("Расчет был остановлен.");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Ошибка при расчете корреляции: {ex.Message}");
        }
        finally
        {
            isCalculating = false;
            isStatusBarVisible = false;
            cancellationTokenSource.Dispose();
            await InvokeAsync(StateHasChanged);
        }
    }

    // Метод для обновления прогресса
    private void UpdateProgress(int progress)
    {
        InvokeAsync(() =>
        {
            currentProgress = progress;
            StateHasChanged();
        });
    }

    // Метод для управления видимостью статусбара
    private void SetStatusBarVisible(bool isVisible)
    {
        InvokeAsync(() =>
        {
            isStatusBarVisible = isVisible;
            StateHasChanged();
        });
    }

    private async Task OnStopCalculation()
    {
        if (cancellationTokenSource != null)
        {
            // Останавливаем текущий расчет
            cancellationTokenSource.Cancel();
            cancellationTokenSource.Dispose();
            cancellationTokenSource = null;
        }

        // Обновляем состояние интерфейса
        isCalculating = false;
        isStatusBarVisible = false;
        await InvokeAsync(StateHasChanged);
    }


    // Метод для применения изменений и расчета корреляции для отфильтрованных ТМ
    private async Task ApplyChangesAndCalculateCorrelation()
    {
        try
        {
            // Подтверждаем действия для текущего списка
            ConfirmActions(filteredTMValues);

            // Получаем последнюю метку эксперимента
            var latestExperimentLabel = await MonitoringService.GetNextExperimentLabelAsync();

            // Инициализируем новый класс
            var experimentCorrData = new ExperimentCorrData(_context);

            // Объединяем наборы из выпадающего списка и вручную введённые номера ТМ
            var selectedTMValues = filteredTMValues;

            if (manualTMInputNumbers != null && manualTMInputNumbers.Any())
            {
                // Преобразуем номера из ручного ввода в список TMValues
                var manualTMValues = await MonitoringService.ManualMonitorSetupAsync(manualTMInputNumbers, selectedTMValues.ToList());

                // Объединяем списки и удаляем дубликаты
                selectedTMValues = selectedTMValues
                    .Union(manualTMValues)
                    .GroupBy(tm => new { tm.IndexTM, tm.Id1, tm.Privyazka })
                    .Select(group => group.First())
                    .ToList();
            }

        }
        finally
        {
            // Восстанавливаем исходное состояние из originalTMValues
            if (originalTMValues != null)
            {
                filteredTMValues = originalTMValues;
                originalTMValues = null; // Сбрасываем оригинал после восстановления
            }

            // Обновляем интерфейс
            await InvokeAsync(StateHasChanged);
        }
    }
}


<button @onclick="ShowChartInput" class="btn btn-primary mt-2">Показать график корреляции</button>


@if (showSearch)
{
    <div class="mb-3">
        <input @bind="searchTerm" placeholder="Поиск по Index TM" class="form-control" />
        <button @onclick="SearchData" class="btn btn-primary mt-2">Искать</button>
        <button @onclick="ResetSearch" class="btn btn-secondary mt-2 ml-2">Сбросить</button>
    </div>
}

@if (showChartInput)
{
    <div class="mb-3">
        <canvas id="chart" width="400" height="200" @ref="chartElement"></canvas>
        <input @bind="tmIndexInput" placeholder="Введите номер ТМ" class="form-control" />
        <button @onclick="GenerateChart" class="btn btn-primary mt-2">Построить график</button>
    </div>
}

@if (chartDataAvailable && showChart)
{
    <div class="mt-4">
        <button @onclick="HideChart" class="btn btn-secondary mb-2">Закрыть график</button>
        <canvas id="chart" width="400" height="200" @ref="chartElement"></canvas>
    </div>
}

<!-- Кнопка для показа выбранных действий -->
@if (selectedActions.Any())
{
    <button class="btn btn-primary" @onclick="ToggleSelectedActions">Показать выбранные действия</button>
}

@if (showModal)
{
    <div class="alert alert-info mt-3">
        <h5>Выбранные действия</h5>
        <h6>Выбранный интервал: от @startDate.Value.ToString("g") до @endDate.Value.ToString("g")</h6>

        <!-- Таблица с выбранными действиями -->
        <table class="table table-bordered mt-3">
            <thead>
                <tr>
                    <th>Индекс ТМ</th>
                    <th>Узел</th>
                    <th>Действие</th>
                </tr>
            </thead>
            <tbody>
                @foreach (var action in selectedActions)
                {
                    <tr>
                        <td>@action.TelemetryId</td>
                        <td>@action.Id1</td>
                        <td>@action.ActionName</td>
                    </tr>
                }
            </tbody>
        </table>

        <!-- Кнопка для выбора отслеживаемых телеизмерений и расчета корреляции -->
        <div class="mt-3">
            <!-- Кнопка для выбора отслеживаемых телеизмерений -->
            <button class="btn btn-primary dropdown-toggle" type="button" @onclick="ToggleMonitoringOptions" aria-expanded="false">
                Выбрать отслеживаемые телеизмерения
            </button>
            @if (showOptions)
            {
                <ul class="dropdown-menu show">
                    <li>
                        <a class="dropdown-item"
                           @onclick="async () =>
                        {
                            var newValues = await MonitoringService.MonitorAllTMAsync(filteredTMValues.ToList());
                            await SetFilteredTMValues(newValues);
                            ToggleMonitoringOptions();
                        }">
                            Отслеживать изменения для всех ТМ
                        </a>
                    </li>
                    <li>
                        <a class="dropdown-item"
                           @onclick="async () =>
                        {
                            var newValues = await MonitoringService.MonitorUnreliableAndQuestionableTMAsync(filteredTMValues.ToList());
                            await SetFilteredTMValues(newValues);
                            ToggleMonitoringOptions();
                        }">
                            Отслеживать изменения для недостоверных и сомнительных ТМ
                        </a>
                    </li>
                    <li>
                        <a class="dropdown-item"
                           @onclick="async () =>
                        {
                            var newValues = await MonitoringService.MonitorUnreliableTMAsync(filteredTMValues.ToList());
                            await SetFilteredTMValues(newValues);
                            ToggleMonitoringOptions();
                        }">
                            Отслеживать изменения для недостоверных ТМ
                        </a>
                    </li>
                    <li>
                        <a class="dropdown-item"
                           @onclick="async () =>
                           {
                                var telemetryKeys = selectedActions
                                    .Select(a => (a.TelemetryId, a.Id1))
                                    .ToList();

                                var newValues = await MonitoringService.MonitorVerifiedTMAsync(telemetryKeys, filteredTMValues.ToList());

                                // Передача обновлённого списка
                                await SetFilteredTMValues(newValues);

                               ToggleMonitoringOptions();
                           }">
                            Отслеживать изменения для ТМ, которые были достоверизованы
                        </a>
                    </li>
                </ul>
            }
            <button class="btn btn-secondary mt-2" @onclick="OpenManualMonitorModal">Задать список отслеживаемых ТМ вручную</button>

        </div>
        @if (showManualMonitorModal)
        {
            <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons/font/bootstrap-icons.css" rel="stylesheet">
            <!-- Модальное окно для ручного ввода списка отслеживаемых ТМ -->
            <div class="modal d-block" tabindex="-1">
                <div class="modal-dialog">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title">Введите номера ТМ для отслеживания</h5>
                            <button type="button" class="btn-close" @onclick="CloseManualMonitorModal"></button>
                        </div>
                        <div class="modal-body">
                            <!-- Информационное сообщение с иконкой -->
                            <div class="mb-2 d-flex align-items-center">
                                <i class="bi bi-info-circle text-primary me-2"></i>
                                <span class="text-muted">
                                    Введите интересующие вас номера ТМ через запятую.
                                </span>
                            </div>
                            <!-- Поле ввода номеров ТМ -->
                            <input type="text" class="form-control" @bind="manualTMInput" placeholder="Введите номера ТМ через запятую">
                            @if (!string.IsNullOrEmpty(errorMessage))
                            {
                                <div class="text-danger mt-2">@errorMessage</div>
                            }
                        </div>
                        <div class="modal-footer">
                            <!-- Кнопка отмены -->
                            <button type="button" class="btn btn-secondary" @onclick="CloseManualMonitorModal">Отмена</button>
                            <!-- Кнопка подтверждения ручного ввода -->
                            <button type="button" class="btn btn-primary" @onclick="ValidateAndSubmitManualTMInput">
                                Подтвердить только введённые вручную ТМ
                            </button>
                            <!-- Кнопка объединения -->
                            @if (selectedTMValues.Any() || !string.IsNullOrEmpty(manualTMInput))
                            {
                                <button class="btn btn-primary" @onclick="async () => await CombineAndSubmitSets()">
                                    Добавить к имеющимся
                                </button>
                            }
                        </div>
                    </div>
                </div>
            </div>
        }

        <!-- Объединенная кнопка для применения изменений и расчета корреляции -->
        <div class="mt-3">
            <button class="btn btn-success" @onclick="ApplyChangesAndCalculateCorrelation">
                Применить изменения и рассчитать корреляцию для отслеживаемых ТМ
            </button>
            <button class="btn btn-secondary" @onclick="CloseModal">Закрыть</button>
        </div>
    </div>
}

@code {
    private bool showOptions = false;

    private void ToggleMonitoringOptions()
    {
        isManualInput = false;
        showOptions = !showOptions;
    }

    private void OpenManualMonitorModal()
    {
        showManualMonitorModal = true;
        errorMessage = string.Empty;
    }

    private void CloseManualMonitorModal()
    {
        showManualMonitorModal = false;
        manualTMInput = string.Empty;
        errorMessage = string.Empty;
    }

    private async Task ValidateAndSubmitManualTMInput()
    {
        isManualInput = true; // Указываем, что данные вводятся вручную

        try
        {
            // Вызываем валидацию через ValidationService
            var validationResult = await ValidationService.ValidateTMInputAsync(manualTMInput);

            if (!validationResult.IsValid)
            {
                errorMessage = string.Join("; ", validationResult.Errors);
                return;
            }

            // Преобразуем список строк в список целых чисел
            var tmNumbers = validationResult.TMNumbers.Select(int.Parse).ToList();

            // Сбрасываем filteredTMValues к исходному состоянию
            if (originalTMValues != null)
            {
                filteredTMValues = new List<TMValues>(originalTMValues);
            }

            // Если валидация прошла успешно, выполняем логику для отслеживания
            var filteredTMValuesAfterValidation =
                await MonitoringService.ManualMonitorSetupAsync(tmNumbers, filteredTMValues.ToList());

            // Если найденных значений нет, выводим сообщение
            if (filteredTMValuesAfterValidation == null || !filteredTMValuesAfterValidation.Any())
            {
                errorMessage = "Не найдено подходящих значений.";
                return;
            }

            // Передаём результат в SetFilteredTMValues для обновления интерфейса
            await SetFilteredTMValues(filteredTMValuesAfterValidation);

            // Закрываем модальное окно
            CloseManualMonitorModal();
        }
        catch (Exception ex)
        {
            // Логируем ошибку и выводим сообщение
            Console.WriteLine($"Ошибка при ручной настройке мониторинга: {ex.Message}");
            errorMessage = "Произошла ошибка при обработке данных. Попробуйте снова.";
        }
    }

    private async Task CombineAndSubmitSets()
    {
        // Обрабатываем ввод вручную перед объединением
        await ValidateAndSubmitManualTMInput();

        // Проверяем, если данные готовы
        if (selectedTMValues.Any() && manualTMValues.Any())
        {
            // Объединяем наборы
            var combinedSet = await MonitoringService.CombineMonitoringSetsAsync(selectedTMValues, manualTMValues);

            // Обновляем интерфейс
            await SetFilteredTMValues(combinedSet);

            // Закрываем модальное окно
            CloseManualMonitorModal();
            await InvokeAsync(StateHasChanged);
        }
    }

    private string GetSelectedAction(int telemetryId, int id1)
    {
        var action = selectedActions.FirstOrDefault(a => a.TelemetryId == telemetryId && a.Id1 == id1);
        return action?.ActionName ?? string.Empty;
    }

}

@if (IsDropdownVisible)
{
    <div class="form-group">
        <label for="experimentSelect">Выберите эксперимент:</label>
        <select id="experimentSelect" class="form-select" @onchange="FilterByExperiment">
            <option value="" selected>Входные данные</option>
            @foreach (var experiment in availableExperiments)
            {
                <option value="@experiment">@experiment</option>
            }
        </select>
    </div>
}



@if (filteredTm == null || !filteredTm.Any())
{
    <p>Нет данных для отображения.</p>
}
else
{
    <div style="overflow-y: auto; max-height: 1000px;">
        <table class="table table-bordered" style="position: relative; border-collapse: collapse; width: 100%; padding:0; margin:0">
            <thead style="position: sticky; top: 0; background-color: white; z-index: 2; padding:0; margin:0">
                <!-- Первый уровень заголовков -->
                <tr>
                    <th colspan="8" class="text-center">Входные данные</th>
                    @if (!string.IsNullOrEmpty(selectedExperiment) && selectedExperiment != "Входные данные")
                    {
                        <th colspan="4" class="text-center">Значения экспериментов</th>
                    }
                </tr>
                <!-- Второй уровень заголовков -->
                <tr>
                    <th @onclick="() => SortData(nameof(NedostovernayaTM.ID))">
                        Идентификатор @(currentSortColumn == nameof(NedostovernayaTM.ID) ? (isAscending ? "▲" : "▼") : "")
                    </th>
                    <th>
                        <span @onclick="() => SortData(nameof(NedostovernayaTM.IndexTm))" style="cursor:pointer;">
                            Индекс ТМ @(currentSortColumn == nameof(NedostovernayaTM.IndexTm) ? (isAscending ? "▲" : "▼") : "")
                        </span>
                        <button @onclick="ToggleSearch" class="btn btn-link" style="padding:0; margin-left:5px;">
                            🔍
                        </button>
                    </th>
                    <th @onclick="() => SortData(nameof(NedostovernayaTM.CorrTm))">
                        Узел @(currentSortColumn == nameof(NedostovernayaTM.Id1) ? (isAscending ? "▲" : "▼") : "")
                    </th>
                    <th @onclick="() => SortData(nameof(NedostovernayaTM.CorrTm))">
                        Коэффициент корреляции @(currentSortColumn == nameof(NedostovernayaTM.CorrTm) ? (isAscending ? "▲" : "▼") : "")
                    </th>
                    <th @onclick="() => SortData(nameof(NedostovernayaTM.Status))">
                        Статус @(currentSortColumn == nameof(NedostovernayaTM.Status) ? (isAscending ? "▲" : "▼") : "")
                    </th>
                    <th @onclick="() => SortData(nameof(NedostovernayaTM.MaxLagranj))">
                        Максимальное значение лагранжиана @(currentSortColumn == nameof(NedostovernayaTM.MaxLagranj) ? (isAscending ? "▲" : "▼") : "")
                    </th>
                    <th @onclick="() => SortData(nameof(NedostovernayaTM.AvgLagranj))">
                        Среднее значение лагранжиана @(currentSortColumn == nameof(NedostovernayaTM.AvgLagranj) ? (isAscending ? "▲" : "▼") : "")
                    </th>
                    <th @onclick="() => SortData(nameof(NedostovernayaTM.recomendedActions))">
                        Действия по достоверизации @(currentSortColumn == nameof(NedostovernayaTM.recomendedActions) ? (isAscending ? "▲" : "▼") : "")
                    </th>
                    @if (!string.IsNullOrEmpty(selectedExperiment) && selectedExperiment != "Входные данные")
                    {
                        <th>Коэффициент корреляции</th>
                        <th>Статус</th>
                        <th>Максимальное значение лагранжиана</th>
                        <th>Среднее значение лагранжиана</th>
                    }
                </tr>
            </thead>
            <tbody>
                @foreach (var telemetry in filteredTm)
                {
                    <tr class="@GetRowClass(telemetry.Status)">

                        @if (string.IsNullOrEmpty(selectedExperiment) || selectedExperiment == "Входные данные")
                        {
                            <!-- Входные данные -->
                            <td>@telemetry.ID</td>
                            <td>@telemetry.IndexTm</td>
                            <td>@telemetry.Id1</td>
                            <td>@Math.Round(telemetry.CorrTm, 4)</td>
                            <td>@telemetry.Status</td>
                            <td>@Math.Round(telemetry.MaxLagranj, 4)</td>
                            <td>@Math.Round(telemetry.AvgLagranj, 4)</td>
                        }
                        else
                        {
                            <!-- Данные для выбранного эксперимента -->
                            <td>@GetExperimentValue(telemetry.IndexTm, "Входные данные", "ID")</td>
                            <td>@GetExperimentValue(telemetry.IndexTm, "Входные данные", "IndexTm")</td>
                            <td>@GetExperimentValue(telemetry.IndexTm, "Входные данные", "Id1")</td>
                            <td>@GetExperimentValue(telemetry.IndexTm, "Входные данные", "CorrTm")</td>
                            <td>@GetExperimentValue(telemetry.IndexTm, "Входные данные", "Status")</td>
                            <td>@GetExperimentValue(telemetry.IndexTm, "Входные данные", "MaxLagranj")</td>
                            <td>@GetExperimentValue(telemetry.IndexTm, "Входные данные", "AvgLagranj")</td>
                        }

                        <td>
                            <select class="form-select"
                                    value="@GetSelectedAction((int)telemetry.IndexTm, telemetry.Id1)"
                                    @onchange="(e) => SelectAction(telemetry, e.Value.ToString())">
                                <option value="">Выберите действие</option>
                                <option value="Изменить знак ТМ">Изменить знак ТМ</option>
                                <option value="Создать дорасчет">Создать дорасчет</option>
                                <option value="Исключить из ОС">Исключить из ОС</option>
                            </select>
                        </td>
                        <!-- Добавляем значения для каждого эксперимента -->
                        @if (!string.IsNullOrEmpty(selectedExperiment) && selectedExperiment != "Входные данные")
                        {

                            <td>@GetExperimentValue(telemetry.IndexTm, selectedExperiment, "CorrTm")</td>
                            <td>@GetExperimentValue(telemetry.IndexTm, selectedExperiment, "Status")</td>
                            <td>@GetExperimentValue(telemetry.IndexTm, selectedExperiment, "MaxLagranj")</td>
                            <td>@GetExperimentValue(telemetry.IndexTm, selectedExperiment, "AvgLagranj")</td>
                        }
                    </tr>
                }
            </tbody>
        </table>
    </div>
}






