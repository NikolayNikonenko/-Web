@page "/preprocessing"
@using перенос_бд_на_Web.Models
@using перенос_бд_на_Web.Services
@using Microsoft.EntityFrameworkCore
@using перенос_бд_на_Web.Pages.TM
@inject ApplicationContext _context
@inject DataFilterService _dataFilterService
@inject ExperimentCorrData corrDataService
@inject CalculationIntervalServiceForPTI CalculationIntervalService

<PageTitle>Предварительная подготовка файлов</PageTitle>

<h3>Предварительная подготовка файлов</h3>

<style>
    .status-dostovernaya {
        background-color: lightgreen;
    }

    .status-somnitelnaya {
        background-color: lightyellow;
    }

    .status-nedostovernaya {
        background-color: lightcoral;
    }
</style>

<div>
    <button class="btn btn-primary mt-2" @onclick="ToggleDateIntervalFields">Задать интервал для расчета ПТИ ДТИ</button>
</div>

@code {
    private DateTime? startDate = null;
    private DateTime? endDate = null;

    private int thinningInterval = 1;
    private bool isThinning = false; // Флаг для прореживания
    private bool showDateIntervalFields = false; // Флаг для отображения полей
    private bool isCalculating = false; // Флаг для отображения прогресса
    private int progress = 0; // Прогресс выполнения
    private bool showCorrelationButton = false; // Показывает кнопку корреляции
    private List<TMValues> preparedDataSet; // Для данных с experiment_label = "Подготовленные данные"
    private bool isStatusBarVisible=false;
    private List<NedostovernayaTM> resultsTable; // Итоговая таблица
    private List<NedostovernayaTM> filteredResultsTable = new(); // Таблица, содержащая только ПТИ и ДТИ
    private bool showResultsTable = false; // Флаг отображения таблицы результатов
    private string currentSortColumn;
    private bool isAscending = true;
    private bool hasPreparedData = false;

    private CalculationIntervalForPTI lastInterval;

    private List<TMValues> filteredData;

    private bool isIntervalApplied = false; // Переменная состояния

    protected override async Task OnInitializedAsync()
    {
        try
        {
            hasPreparedData = await HasPreparedData();
            lastInterval = await CalculationIntervalService.GetLastCalculationInterval();
            if (lastInterval != null)
            {
                startDate = lastInterval.startDate;
                endDate = lastInterval.endDate;
            }
            // Проверяем, есть ли данные с меткой "Подготовленные данные" в таблице tm
            var preparedData = await _context.tm
                .Where(tm => tm.experiment_label == "Подготовленные данные")
                .ToListAsync();

            if (preparedData != null && preparedData.Any())
            {
                resultsTable = preparedData;

                // Фильтруем данные по NameTM
                FilterByNameTM();

                // Показываем таблицу результатов, если после фильтрации есть данные
                showResultsTable = filteredResultsTable.Any();
            }

            else
            {
                showResultsTable = false; // Не показываем таблицу, если данных нет
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Ошибка при инициализации страницы: {ex.Message}");
        }
    }

    private async Task HandleSubmit()
    {
        if (startDate.HasValue && endDate.HasValue)
        {
            await CalculationIntervalService.SaveCalculationInterval(startDate.Value, endDate.Value);
            lastInterval = await CalculationIntervalService.GetLastCalculationInterval();

            isIntervalApplied = true; // Интервал был применен, показываем вторую кнопку

            Console.WriteLine($"Интервал сохранён: {startDate:dd.MM.yyyy HH:mm:ss} - {endDate:dd.MM.yyyy HH:mm:ss}");
            StateHasChanged(); // Обновляем интерфейс
        }
        else
        {
            Console.WriteLine("Ошибка: Не все поля заполнены.");
        }
    }

    private void FilterByNameTM()
    {
        // Фильтруем записи по значениям NameTM
        filteredResultsTable = resultsTable
            .Where(item => item.NameTM != null && (item.NameTM.Contains("ПТИ") || item.NameTM.Contains("ДТИ")))
            .ToList();
    }

    private void SortData(string columnName)
    {
        if (currentSortColumn == columnName)
        {
            // Если столбец тот же, меняем порядок сортировки
            isAscending = !isAscending;
        }
        else
        {
            // Если столбец другой, устанавливаем новую сортировку
            currentSortColumn = columnName;
            isAscending = true;
        }

        // Применяем сортировку
        filteredResultsTable = isAscending
            ? filteredResultsTable.OrderBy(item => GetPropertyValue(item, columnName)).ToList()
            : filteredResultsTable.OrderByDescending(item => GetPropertyValue(item, columnName)).ToList();
    }

    private object GetPropertyValue(NedostovernayaTM item, string propertyName)
    {
        return typeof(NedostovernayaTM).GetProperty(propertyName)?.GetValue(item, null);
    }

    private async Task ApplyFilters()
    {
        try
        {
            filteredData = await _dataFilterService.ApplyTimeIntervalFilterAsync(startDate, endDate, isThinning, thinningInterval);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Ошибка: {ex.Message}");
        }
        HandleSubmit();
    }

    private void ToggleDateIntervalFields()
    {
        showDateIntervalFields = !showDateIntervalFields; // Переключение видимости
    }

    private async Task CalculateDTIForSelectedInterval(DateTime? startDate)
    {
        if (filteredData == null || !filteredData.Any())
        {
            Console.WriteLine("Нет данных для расчёта.");
            return;
        }
        isCalculating = true;
        progress = 0;

        try
        {
            // Предполагаем, что каждый срез имеет путь или идентификатор
            var sliceNames = filteredData.Select(data => data.NumberOfSrez).Distinct().ToList();

            // Извлекаем соответствующие пути из таблицы Slices
            var slicePaths = await _context.slices
                .Where(s => sliceNames.Contains(s.SliceName) && s.experiment_label == "Входные данные")
                .Select(s => s.SlicePath)
                .ToListAsync();

            int totalSlices = slicePaths.Count;
            int processedSlices = 0;

            foreach (var path in slicePaths)
            {
                CalculationDTI dtiCalculation = new CalculationDTI();
                await Task.Run(() => dtiCalculation.CalculateDTIAndPTI(path, _context, startDate));
                processedSlices++;
                progress = (int)((processedSlices / (double)totalSlices) * 100);
                StateHasChanged(); // Обновление UI
            }

            Console.WriteLine("Расчёт завершён.");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Ошибка расчёта: {ex.Message}");
        }
        finally
        {
            isCalculating = false;
            progress = 100; // Устанавливаем прогресс на 100%
            showCorrelationButton = true; // Показываем кнопку корреляции
            StateHasChanged();   
        }
    }

    private async Task CalculateCorrelation()
    {
        progress = 0;
        try
        {
            preparedDataSet = await _context.TMValues
                .Where(tm => tm.experiment_label == "Подготовленные данные")
                .ToListAsync();

            if (preparedDataSet == null || !preparedDataSet.Any())
            {
                Console.WriteLine("Нет подготовленных данных для расчёта корреляции.");
                return;
            }

            // Запуск расчёта с обновлением прогресса и статуса
            await corrDataService.CalculationCorrelationWithExperimentLabel(
                preparedDataSet,
                "Подготовленные данные",
                progress => { this.progress = progress; StateHasChanged(); },
                 isVisible => { this.isStatusBarVisible = isVisible; StateHasChanged(); },
                CancellationToken.None
            );

            // После завершения показать таблицу
            resultsTable = await _context.tm
                .Where(tm => tm.experiment_label == "Подготовленные данные")
                .ToListAsync();

            showResultsTable = true;

            Console.WriteLine("Расчёт корреляции завершён.");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Ошибка расчёта корреляции: {ex.Message}");
        }
    }
    public async Task<bool> HasPreparedData()
    {
        return await _context.tm
            .AnyAsync(t => t.experiment_label == "Подготовленные данные");
    }

    private string GetRowClass(string status)
    {
        return status switch
        {
            "Достоверная" => "status-dostovernaya",
            "Сомнительная" => "status-somnitelnaya",
            "Недостоверная" => "status-nedostovernaya",
            _ => string.Empty
        };
    }

}

@if (isCalculating)
{
    <div class="progress mt-3">
        <div class="progress-bar progress-bar-striped progress-bar-animated"
             role="progressbar"
             style="width: @progress%"
             aria-valuenow="@progress"
             aria-valuemin="0"
             aria-valuemax="100">
            @progress%
        </div>
    </div>
}

@if (showDateIntervalFields)
{
    <div class="d-flex flex-column mt-3">
        <label>Начало временного промежутка:</label>
        <input type="datetime-local" @bind="startDate" class="form-control mb-2" />

        <label>Конец временного промежутка:</label>
        <input type="datetime-local" @bind="endDate" class="form-control" />
    </div>
    @if (isThinning)
    {
        <div class="mt-3">
            <label>Интервал прореживания:</label>
            <input type="number" @bind="thinningInterval" min="1" class="form-control" />
        </div>
    }

    <div class="form-check mt-3">
        <input type="checkbox" @bind="isThinning" class="form-check-input" />
        <label class="form-check-label">Приментиь прореживание</label>
    </div>

    <button class="btn btn-primary mt-2" @onclick="ApplyFilters">Применить заданный интервал</button>
}
@if (isIntervalApplied)
{
    <div>
        <button class="btn btn-primary mt-2"
                @onclick="@(startDate.HasValue ? () => CalculateDTIForSelectedInterval(startDate.Value) : (Action)null)">
            Рассчитать ПТИ и ДТИ для выбранного интервала
        </button>
    </div>
}

@if (showCorrelationButton)
{
    <div>
        <button class="btn btn-primary mt-2" @onclick="CalculateCorrelation">
            Рассчитать корреляцию для ДТИ и ПТИ
        </button>
    </div>
}

@if (isStatusBarVisible)
{
    <div class="progress mt-3">
        <div class="progress-bar progress-bar-striped progress-bar-animated"
             role="progressbar"
             style="width: @progress%"
             aria-valuenow="@progress"
             aria-valuemin="0"
             aria-valuemax="100">
            @progress%
        </div>
    </div>
}

@if (lastInterval != null && hasPreparedData)
{
    <p style="margin-top: 20px;">
        <b>ПТИ и ДТИ рассчитаны для интервала:</b>
        от: <span>@lastInterval.startDate.ToString("dd.MM.yy HH:mm:ss")</span>
        до: <span>@lastInterval.endDate.ToString("dd.MM.yy HH:mm:ss")</span>
    </p>
}


@if (showResultsTable)
{
    <h4 class="mt-4">Результаты расчёта</h4>
    <table class="table table-bordered mt-2">
        <thead>
            <tr>
                <th @onclick="() => SortData(nameof(NedostovernayaTM.ID))">
                    Идентификатор @(currentSortColumn == nameof(NedostovernayaTM.ID) ? (isAscending ? "▲" : "▼") : "")
                </th>
                <th @onclick="() => SortData(nameof(NedostovernayaTM.IndexTm))">
                    Индекс ТМ @(currentSortColumn == nameof(NedostovernayaTM.IndexTm) ? (isAscending ? "▲" : "▼") : "")
                </th>
                <th @onclick="() => SortData(nameof(NedostovernayaTM.CorrTm))">
                    Корреляция @(currentSortColumn == nameof(NedostovernayaTM.CorrTm) ? (isAscending ? "▲" : "▼") : "")
                </th>
                <th @onclick="() => SortData(nameof(NedostovernayaTM.Status))">
                    Статус @(currentSortColumn == nameof(NedostovernayaTM.Status) ? (isAscending ? "▲" : "▼") : "")
                </th>
                <th @onclick="() => SortData(nameof(NedostovernayaTM.MaxLagranj))">
                    Максимальное значение множителя Лагранжа @(currentSortColumn == nameof(NedostovernayaTM.MaxLagranj) ? (isAscending ? "▲" : "▼") : "")
                </th>
                <th @onclick="() => SortData(nameof(NedostovernayaTM.AvgLagranj))">
                    Среднее значение множителя Лагранжа @(currentSortColumn == nameof(NedostovernayaTM.AvgLagranj) ? (isAscending ? "▲" : "▼") : "")
                </th>
            </tr>
        </thead>
        <tbody>
            @foreach (var result in filteredResultsTable)
            {
                <tr class="@GetRowClass(result.Status)">
                    <td>@result.ID</td>
                    <td>@result.IndexTm</td>
                    <td>@Math.Round(result.CorrTm,4)</td>
                    <td>@result.Status</td>
                    <td>@Math.Round(result.MaxLagranj,4)</td>
                    <td>@Math.Round(result.AvgLagranj,4)</td>
                </tr>
            }
        </tbody>
    </table>
}

